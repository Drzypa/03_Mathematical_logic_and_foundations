<!DOCTYPE html><html>
<head>
<title>1.5 Product types</title>
<!--Generated on Thu Feb  8 19:32:28 2018 by LaTeXML (version 0.8.2) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/3f71ceeb3b055e1ddc3b6c11fb1f074c/raw/2bb23e3b173ff96840797fc0c3bcb8c54085df8e/LaTeXML.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/4bda0365b30858ac2fb83623185fe3ec/raw/cedd84ed3e3ad597c5d293f443ecfe4803741c6b/ltx-article.css" type="text/css">
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML" type="text/javascript"></script>
<meta name="keywords" lang="en" content=", , , , , , , , , , , , , , , , , cartesian product, component, of a pair, dependent, dependent eliminator, for cartesian product, for product, for product types, from cartesian product type, function, induction principle, non-dependent, non-dependent eliminator, nullary, of inductive type, of types, ordered, pair, product, projection, recursion principle, recursor, type, unit">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">1.5 Product types</h1>

<div id="p1" class="ltx_para">
<br class="ltx_break">
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">Given types <math id="p2.m1" class="ltx_Math" alttext="A,B:\mathcal{U}" display="inline"><mrow><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo>:</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></math> we introduce the type <math id="p2.m2" class="ltx_Math" alttext="A\times B:\mathcal{U}" display="inline"><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>:</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></math>, which we call their <span class="ltx_text ltx_font_bold"><a class="nnexus_concept" href="http://planetmath.org/cartesianproduct">cartesian product</a></span>.
We also introduce a nullary product type, called the <span class="ltx_text ltx_font_bold">unit type</span> <math id="p2.m3" class="ltx_Math" alttext="\mathbf{1}:\mathcal{U}" display="inline"><mrow><mn>𝟏</mn><mo>:</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></math>.
We intend the elements of <math id="p2.m4" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> to be pairs <math id="p2.m5" class="ltx_Math" alttext="(a,b):A\times B" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mrow></math>, where <math id="p2.m6" class="ltx_Math" alttext="a:A" display="inline"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math> and <math id="p2.m7" class="ltx_Math" alttext="b:B" display="inline"><mrow><mi>b</mi><mo>:</mo><mi>B</mi></mrow></math>, and the only element of <math id="p2.m8" class="ltx_Math" alttext="\mathbf{1}" display="inline"><mn>𝟏</mn></math> to be some particular object <math id="p2.m9" class="ltx_Math" alttext="\star:\mathbf{1}" display="inline"><mrow><mo>⋆</mo><mo>:</mo><mn>𝟏</mn></mrow></math>.
However, unlike in <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">set theory</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/SetTheory.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/settheory"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, where we define <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">ordered pairs</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/OrderedPair.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/orderedpair"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> to be particular sets and then collect them all together into the cartesian product, in <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">type theory</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/typetheory"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/russellstheoryoftypes"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, ordered pairs are a primitive <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">concept</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Concept.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/conceptlattice"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, as are <a class="nnexus_concept" href="http://planetmath.org/function">functions</a>.
</p>
</div>
<div id="Thmprermk1" class="ltx_theorem ltx_theorem_prermk">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Remark 1.5.1</span>.</h6>
<div id="Thmprermk1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">There is a general pattern for <a class="nnexus_concept" href="http://planetmath.org/introduction">introduction</a> of a new kind of type in type theory, and because <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">products</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/product"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/cardinalarithmetic"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> are our second example following this pattern,<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_text ltx_font_upright">The description of <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">universes</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/universe"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/universeofdiscourse"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> above is an exception.</span></span></span></span> it is worth emphasizing the general form:
To specify a type, we specify:</span></p>
<ol id="I1" class="ltx_enumerate">
<li id="I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate"><span class="ltx_text ltx_font_italic">1.</span></span> 
<div id="I1.i1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">how to form new types of this kind, via </span><span class="ltx_text ltx_font_bold ltx_font_italic">formation rules</span><span class="ltx_text ltx_font_italic">.
(For example, we can form the function type </span><math id="I1.i1.p1.m1" class="ltx_Math" alttext="A\to B" display="inline"><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></math><span class="ltx_text ltx_font_italic"> when </span><math id="I1.i1.p1.m2" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math><span class="ltx_text ltx_font_italic"> is a type and when </span><math id="I1.i1.p1.m3" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math><span class="ltx_text ltx_font_italic"> is a type. We can form the dependent function type </span><math id="I1.i1.p1.m4" class="ltx_Math" alttext="\mathchoice{\prod_{x:A}\,}{\mathchoice{{\textstyle\prod_{(x:A)}}}{\prod_{(x:A)%
}}{\prod_{(x:A)}}{\prod_{(x:A)}}}{\mathchoice{{\textstyle\prod_{(x:A)}}}{\prod%
_{(x:A)}}{\prod_{(x:A)}}{\prod_{(x:A)}}}{\mathchoice{{\textstyle\prod_{(x:A)}}%
}{\prod_{(x:A)}}{\prod_{(x:A)}}{\prod_{(x:A)}}}B(x)" display="inline"><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mi>B</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math><span class="ltx_text ltx_font_italic"> when </span><math id="I1.i1.p1.m5" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math><span class="ltx_text ltx_font_italic"> is a type and </span><math id="I1.i1.p1.m6" class="ltx_Math" alttext="B(x)" display="inline"><mrow><mi>B</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math><span class="ltx_text ltx_font_italic"> is a type for </span><math id="I1.i1.p1.m7" class="ltx_Math" alttext="x:A" display="inline"><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></math><span class="ltx_text ltx_font_italic">.)</span></p>
</div>
</li>
<li id="I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate"><span class="ltx_text ltx_font_italic">2.</span></span> 
<div id="I1.i2.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">how to construct elements of that type.
</span><span class="ltx_text ltx_font_italic">These are called the type’s </span><span class="ltx_text ltx_font_bold ltx_font_italic">constructors</span><span class="ltx_text ltx_font_italic"> or </span><span class="ltx_text ltx_font_bold ltx_font_italic">introduction rules</span><span class="ltx_text ltx_font_italic">.
(For example, a function type has one constructor, </span><math id="I1.i2.p1.m1" class="ltx_Math" alttext="\lambda" display="inline"><mi>λ</mi></math><span class="ltx_text ltx_font_italic">-abstraction.
Recall that a direct <a class="nnexus_concept" href="http://planetmath.org/definition">definition</a> like </span><math id="I1.i2.p1.m2" class="ltx_Math" alttext="f(x):\!\!\equiv 2x" display="inline"><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mn>2</mn><mi>x</mi></mrow></math><span class="ltx_text ltx_font_italic"> can equivalently be phrased
as a </span><math id="I1.i2.p1.m3" class="ltx_Math" alttext="\lambda" display="inline"><mi>λ</mi></math><span class="ltx_text ltx_font_italic">-abstraction </span><math id="I1.i2.p1.m4" class="ltx_Math" alttext="f:\!\!\equiv{\lambda}x.\,2x" display="inline"><mrow><mi>f</mi><mo rspace="0pt">:</mo><mo>≡</mo><mi>λ</mi><mi>x</mi><mn>. 2</mn><mi>x</mi></mrow></math><span class="ltx_text ltx_font_italic">.)</span></p>
</div>
</li>
<li id="I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate"><span class="ltx_text ltx_font_italic">3.</span></span> 
<div id="I1.i3.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">how to use elements of that type.
These are called the type’s </span><span class="ltx_text ltx_font_bold ltx_font_italic">eliminators</span><span class="ltx_text ltx_font_italic"> or </span><span class="ltx_text ltx_font_bold ltx_font_italic">elimination rules</span><span class="ltx_text ltx_font_italic">.
(For example, the function type has one eliminator, namely function application.)
</span></p>
</div>
</li>
<li id="I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate"><span class="ltx_text ltx_font_italic">4.</span></span> 
<div id="I1.i4.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">a </span><span class="ltx_text ltx_font_bold ltx_font_italic"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Computation.html">computation</a> rule<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup><span class="ltx_text ltx_font_medium ltx_font_upright">also referred to as </span><math id="I1.i4.p1.m1" class="ltx_Math" alttext="\beta" display="inline"><mi mathvariant="normal">β</mi></math><span class="ltx_text ltx_font_upright">-<a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">reduction</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/diamondlemma"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/division"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup></span></span></span></span></span><span class="ltx_text ltx_font_italic">, which expresses how an eliminator acts on a constructor.
(For example, for functions, the computation rule states that </span><math id="I1.i4.p1.m3" class="ltx_Math" alttext="({\lambda}x.\,\Phi)(a)" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo rspace="4.2pt">.</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></math><span class="ltx_text ltx_font_italic"> is judgmentally equal to the <a class="nnexus_concept" href="http://planetmath.org/substitution">substitution</a> of </span><math id="I1.i4.p1.m4" class="ltx_Math" alttext="a" display="inline"><mi>a</mi></math><span class="ltx_text ltx_font_italic"> for </span><math id="I1.i4.p1.m5" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math><span class="ltx_text ltx_font_italic"> in </span><math id="I1.i4.p1.m6" class="ltx_Math" alttext="\Phi" display="inline"><mi mathvariant="normal">Φ</mi></math><span class="ltx_text ltx_font_italic">.)</span></p>
</div>
</li>
<li id="I1.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate"><span class="ltx_text ltx_font_italic">5.</span></span> 
<div id="I1.i5.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">an optional </span><span class="ltx_text ltx_font_bold ltx_font_italic">uniqueness principle<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">3</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">3</sup><span class="ltx_text ltx_font_medium ltx_font_upright">also referred to as </span><math id="I1.i5.p1.m1" class="ltx_Math" alttext="\eta" display="inline"><mi mathvariant="normal">η</mi></math><span class="ltx_text ltx_font_upright">-expansion</span></span></span></span></span><span class="ltx_text ltx_font_italic">, which expresses
uniqueness of maps into or out of that type.
For some types, the uniqueness principle characterizes maps into the type, by stating that
every element of the type is uniquely determined by the results of applying eliminators to it, and can be reconstructed from those results by applying a constructor—thus expressing how constructors act on eliminators, dually to the computation rule.
(For example, for functions, the uniqueness principle says that any function </span><math id="I1.i5.p1.m3" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math><span class="ltx_text ltx_font_italic"> is judgmentally equal to the “expanded” function </span><math id="I1.i5.p1.m4" class="ltx_Math" alttext="{\lambda}x.\,f(x)" display="inline"><mrow><mrow><mi>λ</mi><mo>⁢</mo><mi>x</mi></mrow><mo rspace="4.2pt">.</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math><span class="ltx_text ltx_font_italic">, and thus is uniquely determined by its values.)
</span><span class="ltx_text ltx_font_italic">For other types, the uniqueness principle says that every map (function) </span><em class="ltx_emph">from</em><span class="ltx_text ltx_font_italic"> that type is uniquely determined by some data. (An example is the coproduct type introduced in §1.7 (</span><span class="ltx_text ltx_font_typewriter ltx_font_italic">http://planetmath.org/17coproducttypes</span><span class="ltx_text ltx_font_italic">), whose uniqueness principle is mentioned in §2.15 (</span><span class="ltx_text ltx_font_typewriter ltx_font_italic">http://planetmath.org/215universalproperties</span><span class="ltx_text ltx_font_italic">).)</span></p>
</div>
<div id="I1.i5.p2" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">When the uniqueness principle is not taken as a rule of judgmental equality, it is often nevertheless provable as a </span><em class="ltx_emph">propositional</em><span class="ltx_text ltx_font_italic"> equality from the other rules for the type.
In this case we call it a </span><span class="ltx_text ltx_font_bold ltx_font_italic">propositional uniqueness principle</span><span class="ltx_text ltx_font_italic">.
(In later chapters we will also occasionally encounter </span><em class="ltx_emph">propositional computation rules</em><span class="ltx_text ltx_font_italic">.)
</span></p>
</div>
</li>
</ol>
<p class="ltx_p"><span class="ltx_text ltx_font_italic">The <a class="nnexus_concept" href="http://planetmath.org/inferencerule">inference rules</a> in §A.3 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/a3homotopytypetheory</span>) are organized and named accordingly; see, for example, §A.2.4 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/a24dependentfunctiontypespitypes</span>), where each possibility is realized.</span></p>
</div>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">The way to construct pairs is <a class="nnexus_concept" href="http://planetmath.org/obvious">obvious</a>: given <math id="p3.m1" class="ltx_Math" alttext="a:A" display="inline"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math> and <math id="p3.m2" class="ltx_Math" alttext="b:B" display="inline"><mrow><mi>b</mi><mo>:</mo><mi>B</mi></mrow></math>, we may form <math id="p3.m3" class="ltx_Math" alttext="(a,b):A\times B" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mrow></math>.
Similarly, there is a unique way to construct elements of <math id="p3.m4" class="ltx_Math" alttext="\mathbf{1}" display="inline"><mn>𝟏</mn></math>, namely we have <math id="p3.m5" class="ltx_Math" alttext="\star:\mathbf{1}" display="inline"><mrow><mo>⋆</mo><mo>:</mo><mn>𝟏</mn></mrow></math>.
We expect that “every element of <math id="p3.m6" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> is a pair”, which is the uniqueness principle for products; we do not assert this as a rule of type theory, but we will prove it later on as a propositional equality.</p>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">Now, how can we <em class="ltx_emph ltx_font_italic">use</em> pairs, i.e. how can we define functions out of a product type?
Let us first consider the definition of a non-dependent function <math id="p4.m1" class="ltx_Math" alttext="f:A\times B\to C" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi>C</mi></mrow></mrow></math>.
Since we intend the only elements of <math id="p4.m2" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> to be pairs, we expect to be able to define such a function by prescribing the result
when <math id="p4.m3" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> is applied to a pair <math id="p4.m4" class="ltx_Math" alttext="(a,b)" display="inline"><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></math>.
We can prescribe these results by providing a function <math id="p4.m5" class="ltx_Math" alttext="g:A\to B\to C" display="inline"><mrow><mi>g</mi><mo>:</mo><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow></mrow></math>.
Thus, we introduce a new rule (the elimination rule for products), which says that for any such <math id="p4.m6" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math>, we can define a function <math id="p4.m7" class="ltx_Math" alttext="f:A\times B\to C" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi>C</mi></mrow></mrow></math> by</p>
<table id="S0.Ex1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex1.m1" class="ltx_Math" alttext="f((a,b)):\!\!\equiv g(a)(b)." display="block"><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">We avoid writing <math id="p4.m8" class="ltx_Math" alttext="g(a,b)" display="inline"><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></math> here, in order to emphasize that <math id="p4.m9" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> is not a function on a product.
(However, later on in the book we will often write <math id="p4.m10" class="ltx_Math" alttext="g(a,b)" display="inline"><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></math> both for functions on a product and for <a class="nnexus_concept" href="http://planetmath.org/currying">curried functions</a> of two <a class="nnexus_concept" href="http://planetmath.org/variable">variables</a>.)
This defining equation is the computation rule for product types.
</p>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">Note that in set theory, we would justify the above definition of <math id="p5.m1" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> by the fact that every element of <math id="p5.m2" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> is a pair, so that it suffices to define <math id="p5.m3" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> on pairs.
By contrast, type theory reverses the situation: we assume that a function on <math id="p5.m4" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> is <a class="nnexus_concept" href="http://planetmath.org/welldefined">well-defined</a> as soon as we specify its values on tuples, and from this (or more precisely, from its more general version for dependent functions, below) we will be able to <em class="ltx_emph ltx_font_italic">prove</em> that every element of <math id="p5.m5" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> is a pair.
From a category-theoretic <a class="nnexus_concept" href="http://mathworld.wolfram.com/Perspective.html">perspective</a>, we can say that we define the product <math id="p5.m6" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> to be left adjoint to the “exponential” <math id="p5.m7" class="ltx_Math" alttext="B\to C" display="inline"><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow></math>, which we have already introduced.</p>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">As an example, we can derive the <span class="ltx_text ltx_font_bold"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Projection.html">projection</a></span>
functions
</p>
<table id="S0.EGx1" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tr id="S0.Ex2" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex2.m1" class="ltx_Math" alttext="\displaystyle\mathsf{pr}_{1}" display="inline"><msub><mi>𝗉𝗋</mi><mn>1</mn></msub></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex2.m2" class="ltx_Math" alttext="\displaystyle:A\times B\to A" display="inline"><mrow><mi></mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi>A</mi></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr id="S0.Ex3" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex3.m1" class="ltx_Math" alttext="\displaystyle\mathsf{pr}_{2}" display="inline"><msub><mi>𝗉𝗋</mi><mn>2</mn></msub></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex3.m2" class="ltx_Math" alttext="\displaystyle:A\times B\to B" display="inline"><mrow><mi></mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi>B</mi></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with the defining equations</p>
<table id="S0.EGx2" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tr id="S0.Ex4" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex4.m1" class="ltx_Math" alttext="\displaystyle\mathsf{pr}_{1}((a,b))" display="inline"><mrow><msub><mi>𝗉𝗋</mi><mn>1</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex4.m2" class="ltx_Math" alttext="\displaystyle:\!\!\equiv a" display="inline"><mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>a</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr id="S0.Ex5" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex5.m1" class="ltx_Math" alttext="\displaystyle\mathsf{pr}_{2}((a,b))" display="inline"><mrow><msub><mi>𝗉𝗋</mi><mn>2</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex5.m2" class="ltx_Math" alttext="\displaystyle:\!\!\equiv b." display="inline"><mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>b</mi><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Rather than invoking this principle of function definition every time we want to define a function, an alternative approach is to invoke it once, in a <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">universal</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/universalstructure"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/universalrelation"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> case, and then simply apply the resulting function in all other cases.
That is, we may define a function of type
</p>
<table id="S0.E1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.E1.m1" class="ltx_Math" alttext="\mathsf{rec}_{A\times B}:\mathchoice{\prod_{C:\mathcal{U}}\,}{\mathchoice{{%
\textstyle\prod_{(C:\mathcal{U})}}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:%
\mathcal{U})}}{\prod_{(C:\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:%
\mathcal{U})}}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:%
\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:\mathcal{U})}}}{\prod_{(C:%
\mathcal{U})}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:\mathcal{U})}}}(A\to B\to C)%
\to A\times B\to C" display="block"><mrow><msub><mi>𝗋𝖾𝖼</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mo>:</mo><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>C</mi><mo>:</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></munder></mpadded><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(1.5.2)</span></td>
</tr>
</table>
<p class="ltx_p">with the defining equation</p>
<table id="S0.Ex6" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex6.m1" class="ltx_Math" alttext="\mathsf{rec}_{A\times B}(C,g,(a,b)):\!\!\equiv g(a)(b)." display="block"><mrow><msub><mi>𝗋𝖾𝖼</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>g</mi><mo>,</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Then instead of defining functions such as <math id="p6.m1" class="ltx_Math" alttext="\mathsf{pr}_{1}" display="inline"><msub><mi>𝗉𝗋</mi><mn>1</mn></msub></math> and <math id="p6.m2" class="ltx_Math" alttext="\mathsf{pr}_{2}" display="inline"><msub><mi>𝗉𝗋</mi><mn>2</mn></msub></math> directly by a defining equation, we could define</p>
<table id="S0.EGx3" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tr id="S0.Ex7" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex7.m1" class="ltx_Math" alttext="\displaystyle\mathsf{pr}_{1}" display="inline"><msub><mi>𝗉𝗋</mi><mn>1</mn></msub></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex7.m2" class="ltx_Math" alttext="\displaystyle:\!\!\equiv\mathsf{rec}_{A\times B}(A,{\lambda}a.\,{\lambda}b.\,a)" display="inline"><mrow><mo rspace="0pt">:</mo><mo>≡</mo><msub><mi>𝗋𝖾𝖼</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>λ</mi><mi>a</mi><mo rspace="4.2pt">.</mo><mi>λ</mi><mi>b</mi><mo rspace="4.2pt">.</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr id="S0.Ex8" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex8.m1" class="ltx_Math" alttext="\displaystyle\mathsf{pr}_{2}" display="inline"><msub><mi>𝗉𝗋</mi><mn>2</mn></msub></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex8.m2" class="ltx_Math" alttext="\displaystyle:\!\!\equiv\mathsf{rec}_{A\times B}(B,{\lambda}a.\,{\lambda}b.\,b)." display="inline"><mrow><mo rspace="0pt">:</mo><mo>≡</mo><msub><mi>𝗋𝖾𝖼</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>B</mi><mo>,</mo><mi>λ</mi><mi>a</mi><mo rspace="4.2pt">.</mo><mi>λ</mi><mi>b</mi><mo rspace="4.2pt">.</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">We refer to the function <math id="p6.m3" class="ltx_Math" alttext="\mathsf{rec}_{A\times B}" display="inline"><msub><mi>𝗋𝖾𝖼</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub></math> as the <span class="ltx_text ltx_font_bold">recursor</span>
for product types. The name “recursor” is a bit unfortunate here, since no <a class="nnexus_concept" href="http://mathworld.wolfram.com/Recursion.html">recursion</a> is taking place. It comes from the fact that product types are a degenerate example of a general framework for inductive types, and for types such as the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">natural numbers</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/NaturalNumber.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/naturalnumber"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, the recursor will actually be <a class="nnexus_concept" href="http://planetmath.org/arithmeticalhierarchy">recursive</a>. We may also speak of the <span class="ltx_text ltx_font_bold">recursion principle</span> for cartesian products, meaning the fact that we can define a function <math id="p6.m4" class="ltx_Math" alttext="f:A\times B\to C" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi>C</mi></mrow></mrow></math> as above by giving its value on pairs.
</p>
</div>
<div id="p7" class="ltx_para">
<p class="ltx_p">We leave it as a simple exercise to show that the recursor can be
derived from the projections and vice versa.
</p>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">We also have a recursor for the unit type:</p>
<table id="S0.Ex9" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex9.m1" class="ltx_Math" alttext="\mathsf{rec}_{\mathbf{1}}:\mathchoice{\prod_{C:\mathcal{U}}\,}{\mathchoice{{%
\textstyle\prod_{(C:\mathcal{U})}}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:%
\mathcal{U})}}{\prod_{(C:\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:%
\mathcal{U})}}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:%
\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:\mathcal{U})}}}{\prod_{(C:%
\mathcal{U})}}{\prod_{(C:\mathcal{U})}}{\prod_{(C:\mathcal{U})}}}C\to\mathbf{1%
}\to C" display="block"><mrow><msub><mi>𝗋𝖾𝖼</mi><mn>𝟏</mn></msub><mo>:</mo><mrow><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>C</mi><mo>:</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></munder></mpadded><mi>C</mi></mrow><mo>→</mo><mn>𝟏</mn><mo>→</mo><mi>C</mi></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with the defining equation</p>
<table id="S0.Ex10" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex10.m1" class="ltx_Math" alttext="\mathsf{rec}_{\mathbf{1}}(C,c,\star):\!\!\equiv c." display="block"><mrow><msub><mi>𝗋𝖾𝖼</mi><mn>𝟏</mn></msub><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>c</mi><mo>,</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>c</mi><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Although we include it to maintain the pattern of type definitions, the recursor for <math id="p8.m1" class="ltx_Math" alttext="\mathbf{1}" display="inline"><mn>𝟏</mn></math> is completely useless,
because we could have defined such a function directly
by simply ignoring the <a class="nnexus_concept" href="http://planetmath.org/argument">argument</a> of type <math id="p8.m2" class="ltx_Math" alttext="\mathbf{1}" display="inline"><mn>𝟏</mn></math>.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">To be able to define <em class="ltx_emph ltx_font_italic">dependent</em> functions over the product type, we have
to generalize the recursor. Given <math id="p9.m1" class="ltx_Math" alttext="C:A\times B\to\mathcal{U}" display="inline"><mrow><mi>C</mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></mrow></math>, we may
define a function <math id="p9.m2" class="ltx_Math" alttext="f:\mathchoice{\prod_{x:A\times B}\,}{\mathchoice{{\textstyle\prod_{(x:A\times B%
)}}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}}{%
\mathchoice{{\textstyle\prod_{(x:A\times B)}}}{\prod_{(x:A\times B)}}{\prod_{(%
x:A\times B)}}{\prod_{(x:A\times B)}}}{\mathchoice{{\textstyle\prod_{(x:A%
\times B)}}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B%
)}}}C(x)" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math> by providing a
function
<math id="p9.m3" class="ltx_Math" alttext="g:\mathchoice{\prod_{x:A}\,}{\mathchoice{{\textstyle\prod_{(x:A)}}}{\prod_{(x:%
A)}}{\prod_{(x:A)}}{\prod_{(x:A)}}}{\mathchoice{{\textstyle\prod_{(x:A)}}}{%
\prod_{(x:A)}}{\prod_{(x:A)}}{\prod_{(x:A)}}}{\mathchoice{{\textstyle\prod_{(x%
:A)}}}{\prod_{(x:A)}}{\prod_{(x:A)}}{\prod_{(x:A)}}}\mathchoice{\prod_{y:B}\,}%
{\mathchoice{{\textstyle\prod_{(y:B)}}}{\prod_{(y:B)}}{\prod_{(y:B)}}{\prod_{(%
y:B)}}}{\mathchoice{{\textstyle\prod_{(y:B)}}}{\prod_{(y:B)}}{\prod_{(y:B)}}{%
\prod_{(y:B)}}}{\mathchoice{{\textstyle\prod_{(y:B)}}}{\prod_{(y:B)}}{\prod_{(%
y:B)}}{\prod_{(y:B)}}}C((x,y))" display="inline"><mrow><mi>g</mi><mo>:</mo><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>
with defining equation</p>
<table id="S0.Ex11" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex11.m1" class="ltx_Math" alttext="f((x,y)):\!\!\equiv g(x)(y)." display="block"><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">For example, in this way we can prove the propositional uniqueness principle, which says that every element of <math id="p9.m4" class="ltx_Math" alttext="A\times B" display="inline"><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></math> is equal to a pair.
Specifically, we can construct a function
</p>
<table id="S0.Ex12" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex12.m1" class="ltx_Math" alttext="\mathsf{uppt}:\mathchoice{\prod_{x:A\times B}\,}{\mathchoice{{\textstyle\prod_%
{(x:A\times B)}}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}{\prod_{(x:A%
\times B)}}}{\mathchoice{{\textstyle\prod_{(x:A\times B)}}}{\prod_{(x:A\times B%
)}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}}{\mathchoice{{\textstyle%
\prod_{(x:A\times B)}}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}{\prod_{(%
x:A\times B)}}}((\mathsf{pr}_{1}{(x)},\mathsf{pr}_{2}{(x)})=_{A\times B}x)." display="block"><mrow><mi>𝗎𝗉𝗉𝗍</mi><mo>:</mo><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>x</mi><mo>:</mo><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mrow></munder></mpadded><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝗉𝗋</mi><mn>1</mn></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>,</mo><msub><mi>𝗉𝗋</mi><mn>2</mn></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><msub><mo>=</mo><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Here we are using the identity type, which we are going to introduce below in §1.12 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/112identitytypes</span>).
However, all we need to know now is that there is a <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">reflexivity</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Reflexivity.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/reflexiverelation"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> <a class="nnexus_concept" href="http://mathworld.wolfram.com/Element.html">element</a> <math id="p9.m5" class="ltx_Math" alttext="\mathsf{refl}_{x}:x=_{A}x" display="inline"><mrow><msub><mi>𝗋𝖾𝖿𝗅</mi><mi>x</mi></msub><mo>:</mo><mrow><mi>x</mi><msub><mo>=</mo><mi>A</mi></msub><mi>x</mi></mrow></mrow></math> for any <math id="p9.m6" class="ltx_Math" alttext="x:A" display="inline"><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></math>.
Given this, we can define</p>
<table id="S0.Ex13" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex13.m1" class="ltx_Math" alttext="\mathsf{uppt}((a,b)):\!\!\equiv\mathsf{refl}_{(a,b)}." display="block"><mrow><mi>𝗎𝗉𝗉𝗍</mi><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><msub><mi>𝗋𝖾𝖿𝗅</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">This construction works, because in the case that <math id="p9.m7" class="ltx_Math" alttext="x:\!\!\equiv(a,b)" display="inline"><mrow><mi>x</mi><mo rspace="0pt">:</mo><mo>≡</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></math> we can
<a class="nnexus_concept" href="http://planetmath.org/searchproblem">calculate</a></p>
<table id="S0.Ex14" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex14.m1" class="ltx_Math" alttext="(\mathsf{pr}_{1}((a,b)),\mathsf{pr}_{2}{((a,b))})\equiv(a,b)" display="block"><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>𝗉𝗋</mi><mn>1</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><msub><mi>𝗉𝗋</mi><mn>2</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>≡</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">using the defining equations for the projections. Therefore,</p>
<table id="S0.Ex15" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex15.m1" class="ltx_Math" alttext="\mathsf{refl}_{(a,b)}:(\mathsf{pr}_{1}((a,b)),\mathsf{pr}_{2}{((a,b))})=(a,b)" display="block"><mrow><msub><mi>𝗋𝖾𝖿𝗅</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>𝗉𝗋</mi><mn>1</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><msub><mi>𝗉𝗋</mi><mn>2</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">is well-typed, since both sides of the equality are judgmentally equal.</p>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">More generally, the ability to define dependent functions in this way means that to prove a <a class="nnexus_concept" href="http://planetmath.org/property">property</a> for all elements of a product, it is enough
to prove it for its <a class="nnexus_concept" href="http://planetmath.org/canonical">canonical</a> elements, the tuples.
When we come to inductive types such as the natural numbers, the analogous property will be the ability to write proofs by induction.
Thus, if we do as we did above and apply this principle once in the universal case, we call the resulting function <span class="ltx_text ltx_font_bold"><a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">induction</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Induction.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/induction"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup></span> for product types: given <math id="p10.m1" class="ltx_Math" alttext="A,B:\mathcal{U}" display="inline"><mrow><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo>:</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></math> we have</p>
<table id="S0.Ex16" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex16.m1" class="ltx_Math" alttext="\mathsf{ind}_{A\times B}:\mathchoice{\prod_{C:A\times B\to\mathcal{U}}\,}{%
\mathchoice{{\textstyle\prod_{(C:A\times B\to\mathcal{U})}}}{\prod_{(C:A\times
B%
\to\mathcal{U})}}{\prod_{(C:A\times B\to\mathcal{U})}}{\prod_{(C:A\times B\to%
\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:A\times B\to\mathcal{U})}}}{%
\prod_{(C:A\times B\to\mathcal{U})}}{\prod_{(C:A\times B\to\mathcal{U})}}{%
\prod_{(C:A\times B\to\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:A\times
B%
\to\mathcal{U})}}}{\prod_{(C:A\times B\to\mathcal{U})}}{\prod_{(C:A\times B\to%
\mathcal{U})}}{\prod_{(C:A\times B\to\mathcal{U})}}}\Bigl{(}\mathchoice{\prod_%
{(x:A)}\,}{\mathchoice{{\textstyle\prod_{(x:A)}}}{\prod_{(x:A)}}{\prod_{(x:A)}%
}{\prod_{(x:A)}}}{\mathchoice{{\textstyle\prod_{(x:A)}}}{\prod_{(x:A)}}{\prod_%
{(x:A)}}{\prod_{(x:A)}}}{\mathchoice{{\textstyle\prod_{(x:A)}}}{\prod_{(x:A)}}%
{\prod_{(x:A)}}{\prod_{(x:A)}}}\mathchoice{\prod_{(y:B)}\,}{\mathchoice{{%
\textstyle\prod_{(y:B)}}}{\prod_{(y:B)}}{\prod_{(y:B)}}{\prod_{(y:B)}}}{%
\mathchoice{{\textstyle\prod_{(y:B)}}}{\prod_{(y:B)}}{\prod_{(y:B)}}{\prod_{(y%
:B)}}}{\mathchoice{{\textstyle\prod_{(y:B)}}}{\prod_{(y:B)}}{\prod_{(y:B)}}{%
\prod_{(y:B)}}}C((x,y))\Bigr{)}\to\mathchoice{\prod_{x:A\times B}\,}{%
\mathchoice{{\textstyle\prod_{(x:A\times B)}}}{\prod_{(x:A\times B)}}{\prod_{(%
x:A\times B)}}{\prod_{(x:A\times B)}}}{\mathchoice{{\textstyle\prod_{(x:A%
\times B)}}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}{\prod_{(x:A\times B%
)}}}{\mathchoice{{\textstyle\prod_{(x:A\times B)}}}{\prod_{(x:A\times B)}}{%
\prod_{(x:A\times B)}}{\prod_{(x:A\times B)}}}C(x)" display="block"><mrow><msub><mi>𝗂𝗇𝖽</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mo>:</mo><mrow><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>C</mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><mo>→</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></mrow></munder></mpadded><mrow><mo maxsize="160%" minsize="160%">(</mo><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></munder></mpadded><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></munder></mpadded><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo maxsize="160%" minsize="160%">)</mo></mrow></mrow><mo>→</mo><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>x</mi><mo>:</mo><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mrow></munder></mpadded><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with the defining equation</p>
<table id="S0.Ex17" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex17.m1" class="ltx_Math" alttext="\mathsf{ind}_{A\times B}(C,g,(a,b)):\!\!\equiv g(a)(b)." display="block"><mrow><msub><mi>𝗂𝗇𝖽</mi><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>g</mi><mo>,</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Similarly, we may speak of a dependent function defined on pairs being obtained from the <span class="ltx_text ltx_font_bold">induction principle</span>
of the cartesian product.
It is easy to see that the recursor is just the special case of induction
in the case that the family <math id="p10.m2" class="ltx_Math" alttext="C" display="inline"><mi>C</mi></math> is <a class="nnexus_concept" href="http://planetmath.org/logicallanguage">constant</a>.
Because induction describes how to use an element of the product type, induction is also called the <span class="ltx_text ltx_font_bold">(dependent) eliminator</span>,
and recursion the <span class="ltx_text ltx_font_bold">non-dependent eliminator</span>.
</p>
</div>
<div id="p11" class="ltx_para">
<p class="ltx_p">Induction for the unit type turns out to be more useful than the
recursor:</p>
<table id="S0.Ex18" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex18.m1" class="ltx_Math" alttext="\mathsf{ind}_{\mathbf{1}}:\mathchoice{\prod_{C:\mathbf{1}\to\mathcal{U}}\,}{%
\mathchoice{{\textstyle\prod_{(C:\mathbf{1}\to\mathcal{U})}}}{\prod_{(C:%
\mathbf{1}\to\mathcal{U})}}{\prod_{(C:\mathbf{1}\to\mathcal{U})}}{\prod_{(C:%
\mathbf{1}\to\mathcal{U})}}}{\mathchoice{{\textstyle\prod_{(C:\mathbf{1}\to%
\mathcal{U})}}}{\prod_{(C:\mathbf{1}\to\mathcal{U})}}{\prod_{(C:\mathbf{1}\to%
\mathcal{U})}}{\prod_{(C:\mathbf{1}\to\mathcal{U})}}}{\mathchoice{{\textstyle%
\prod_{(C:\mathbf{1}\to\mathcal{U})}}}{\prod_{(C:\mathbf{1}\to\mathcal{U})}}{%
\prod_{(C:\mathbf{1}\to\mathcal{U})}}{\prod_{(C:\mathbf{1}\to\mathcal{U})}}}C(%
\star)\to\mathchoice{\prod_{x:\mathbf{1}}\,}{\mathchoice{{\textstyle\prod_{(x:%
\mathbf{1})}}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:%
\mathbf{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbf{1})}}}{\prod_{(x:%
\mathbf{1})}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:\mathbf{1})}}}{\mathchoice{{%
\textstyle\prod_{(x:\mathbf{1})}}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:\mathbf{1%
})}}{\prod_{(x:\mathbf{1})}}}C(x)" display="block"><mrow><msub><mi>𝗂𝗇𝖽</mi><mn>𝟏</mn></msub><mo>:</mo><mrow><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>C</mi><mo>:</mo><mrow><mn>𝟏</mn><mo>→</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></mrow></munder></mpadded><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>→</mo><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>x</mi><mo>:</mo><mn>𝟏</mn></mrow></munder></mpadded><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with the defining equation</p>
<table id="S0.Ex19" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex19.m1" class="ltx_Math" alttext="\mathsf{ind}_{\mathbf{1}}(C,c,\star):\!\!\equiv c." display="block"><mrow><msub><mi>𝗂𝗇𝖽</mi><mn>𝟏</mn></msub><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>c</mi><mo>,</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>c</mi><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Induction enables us to prove the propositional uniqueness principle for <math id="p11.m1" class="ltx_Math" alttext="\mathbf{1}" display="inline"><mn>𝟏</mn></math>, which asserts that its only inhabitant is <math id="p11.m2" class="ltx_Math" alttext="\star" display="inline"><mo>⋆</mo></math>.
That is, we can construct</p>
<table id="S0.Ex20" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex20.m1" class="ltx_Math" alttext="\mathsf{upun}:\mathchoice{\prod_{x:\mathbf{1}}\,}{\mathchoice{{\textstyle\prod%
_{(x:\mathbf{1})}}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:%
\mathbf{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbf{1})}}}{\prod_{(x:%
\mathbf{1})}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:\mathbf{1})}}}{\mathchoice{{%
\textstyle\prod_{(x:\mathbf{1})}}}{\prod_{(x:\mathbf{1})}}{\prod_{(x:\mathbf{1%
})}}{\prod_{(x:\mathbf{1})}}}x=\star" display="block"><mrow><mi>𝗎𝗉𝗎𝗇</mi><mo>:</mo><mrow><mrow><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>x</mi><mo>:</mo><mn>𝟏</mn></mrow></munder></mpadded><mi>x</mi></mrow><mo>=</mo><mo>⋆</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">by using the defining equations</p>
<table id="S0.Ex21" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex21.m1" class="ltx_Math" alttext="\mathsf{upun}(\star):\!\!\equiv\mathsf{refl}_{\star}" display="block"><mrow><mi>𝗎𝗉𝗎𝗇</mi><mrow><mo stretchy="false">(</mo><mo>⋆</mo><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><msub><mi>𝗋𝖾𝖿𝗅</mi><mo>⋆</mo></msub></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">or equivalently by using induction:</p>
<table id="S0.Ex22" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex22.m1" class="ltx_Math" alttext="\mathsf{upun}:\!\!\equiv\mathsf{ind}_{\mathbf{1}}({\lambda}x.\,x=\star,\mathsf%
{refl}_{\star})." display="block"><mrow><mi>𝗎𝗉𝗎𝗇</mi><mo rspace="0pt">:</mo><mo>≡</mo><msub><mi>𝗂𝗇𝖽</mi><mn>𝟏</mn></msub><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo rspace="4.2pt">.</mo><mi>x</mi><mo>=</mo><mo>⋆</mo><mo>,</mo><msub><mi>𝗋𝖾𝖿𝗅</mi><mo>⋆</mo></msub><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="p12" class="ltx_para ltx_align_right">
<table class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_l ltx_border_t">Title</th>
<th class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_r ltx_border_t">1.5 Product types</th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_l ltx_border_t"><span class="ltx_ERROR undefined">\metatable</span></td>
<td class="ltx_td ltx_border_t"></td>
</tr>
</tbody>
</table>
</div>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Feb  8 19:32:28 2018 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
