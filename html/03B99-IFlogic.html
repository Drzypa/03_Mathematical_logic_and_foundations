<!DOCTYPE html><html>
<head>
<title>IF-logic</title>
<!--Generated on Thu Feb  8 19:54:02 2018 by LaTeXML (version 0.8.2) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/3f71ceeb3b055e1ddc3b6c11fb1f074c/raw/2bb23e3b173ff96840797fc0c3bcb8c54085df8e/LaTeXML.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/4bda0365b30858ac2fb83623185fe3ec/raw/cedd84ed3e3ad597c5d293f443ecfe4803741c6b/ltx-article.css" type="text/css">
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">IF-logic</h1>

<div id="p1" class="ltx_para">
<br class="ltx_break">
<p class="ltx_p"><em class="ltx_emph ltx_font_italic">Independence Friendly logic</em> (IF-logic) is an interesting conservative extension of classical first-order logic based on very natural ideas from game theoretical semantics developed by Jaakko Hintikka and Gabriel Sandu among others. Although IF-logic is a conservative extension of first order logic, it has a number of interesting properties, such as allowing truth-definitions and admitting a translation of all <math id="p1.m1" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> sentences (second-order sentences with an initial second-order existential quantifier followed by a first-order sentence).</p>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">IF-logic can be characterised as the natural extension of first-order logic when one allows informational independence to occur in the game-theoretical truth definition. To understand this idea we need first to introduce the game theoretical definition of truth for classical first-order logic.</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">To each first-order sentence <math id="p3.m1" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> we assign a game <math id="p3.m2" class="ltx_Math" alttext="G(\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></mrow></math> with two players played on models of the appropriate language. The two players are called <span class="ltx_text ltx_font_italic">verifier</span> and <span class="ltx_text ltx_font_italic">falsifier</span> (or <span class="ltx_text ltx_font_italic">nature</span>). The idea is that the <span class="ltx_text ltx_font_italic">verifier</span> attempts to show that the sentence is true in the model, while the <span class="ltx_text ltx_font_italic">falsifier</span> attempts to show that it is false in the model. The game <math id="p3.m3" class="ltx_Math" alttext="G(\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></mrow></math> is defined as follows. We will use the convention that if <math id="p3.m4" class="ltx_Math" alttext="p" display="inline"><mi>p</mi></math> is a symbol that names a function, a predicate or an object of the model <math id="p3.m5" class="ltx_Math" alttext="M" display="inline"><mi>M</mi></math>, then <math id="p3.m6" class="ltx_Math" alttext="p^{M}" display="inline"><msup><mi>p</mi><mi>M</mi></msup></math> is that named entity.</p>
</div>
<div id="p4" class="ltx_para">
<ul id="I1" class="ltx_itemize">
<li id="I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i1.p1" class="ltx_para">
<p class="ltx_p">if <math id="I1.i1.p1.m1" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math> is an <math id="I1.i1.p1.m2" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>-ary predicate and <math id="I1.i1.p1.m3" class="ltx_Math" alttext="t_{i}" display="inline"><msub><mi>t</mi><mi>i</mi></msub></math> are names of elements of the
model, then <math id="I1.i1.p1.m4" class="ltx_Math" alttext="G(P(t_{1},...,t_{n}))" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math> is a game in which the verifier
immediately wins if <math id="I1.i1.p1.m5" class="ltx_Math" alttext="(t^{M}_{1},...,t^{M}_{n})\in P^{M}" display="inline"><mrow><mrow><mo stretchy="false">(</mo><msubsup><mi>t</mi><mn>1</mn><mi>M</mi></msubsup><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msubsup><mi>t</mi><mi>n</mi><mi>M</mi></msubsup><mo stretchy="false">)</mo></mrow><mo>∈</mo><msup><mi>P</mi><mi>M</mi></msup></mrow></math>, otherwise
the falsifier immediately wins.</p>
</div>
</li>
<li id="I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i2.p1" class="ltx_para">
<p class="ltx_p">the game <math id="I1.i2.p1.m1" class="ltx_Math" alttext="G(\phi_{1}\vee\phi_{2})" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>ϕ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>ϕ</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math> begins with the choice <math id="I1.i2.p1.m2" class="ltx_Math" alttext="\phi_{i}" display="inline"><msub><mi>ϕ</mi><mi>i</mi></msub></math> from
<math id="I1.i2.p1.m3" class="ltx_Math" alttext="\phi_{1}" display="inline"><msub><mi>ϕ</mi><mn>1</mn></msub></math> and <math id="I1.i2.p1.m4" class="ltx_Math" alttext="\phi_{2}" display="inline"><msub><mi>ϕ</mi><mn>2</mn></msub></math> (<math id="I1.i2.p1.m5" class="ltx_Math" alttext="i=1" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></math> or <math id="I1.i2.p1.m6" class="ltx_Math" alttext="i=2" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow></math>) by the verifier, and then
proceeds as the game <math id="I1.i2.p1.m7" class="ltx_Math" alttext="G(\phi_{i})" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math></p>
</div>
</li>
<li id="I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i3.p1" class="ltx_para">
<p class="ltx_p">the game <math id="I1.i3.p1.m1" class="ltx_Math" alttext="G(\phi_{1}\wedge\phi_{2})" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>ϕ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>ϕ</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math> is the same as <math id="I1.i3.p1.m2" class="ltx_Math" alttext="G(\phi_{1}\vee\phi_{2})" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>ϕ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>ϕ</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, except that the choice is made by the falsifier</p>
</div>
</li>
<li id="I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i4.p1" class="ltx_para">
<p class="ltx_p">the game <math id="I1.i4.p1.m1" class="ltx_Math" alttext="G(\exists x\phi(x))" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo>∃</mo><mrow><mi>x</mi><mo>⁢</mo><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math> begins with the choice by verifier
of a member of <math id="I1.i4.p1.m2" class="ltx_Math" alttext="M" display="inline"><mi>M</mi></math> which is given a name <math id="I1.i4.p1.m3" class="ltx_Math" alttext="\mathbf{a}" display="inline"><mi>𝐚</mi></math>, and then proceeds
as <math id="I1.i4.p1.m4" class="ltx_Math" alttext="G(\phi(\mathbf{a}))" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝐚</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math></p>
</div>
</li>
<li id="I1.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i5.p1" class="ltx_para">
<p class="ltx_p">the game <math id="I1.i5.p1.m1" class="ltx_Math" alttext="G(\forall x\phi(x))" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math> is the same as <math id="I1.i5.p1.m2" class="ltx_Math" alttext="G(\exists x\phi(x))" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo>∃</mo><mrow><mi>x</mi><mo>⁢</mo><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>,
except that the choice of <math id="I1.i5.p1.m3" class="ltx_Math" alttext="\mathbf{a}" display="inline"><mi>𝐚</mi></math> is made by the falsifier</p>
</div>
</li>
<li id="I1.i6" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i6.p1" class="ltx_para">
<p class="ltx_p">the game <math id="I1.i6.p1.m1" class="ltx_Math" alttext="G(\neg\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">¬</mi><mo>⁢</mo><mi>ϕ</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math> is the same as <math id="I1.i6.p1.m2" class="ltx_Math" alttext="G(\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></mrow></math> with the roles of the
falsifier and verifier exchanged</p>
</div>
</li>
</ul>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">Truth of a sentence <math id="p5.m1" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> is defined as the existence of a winning strategy for verifier for the game <math id="p5.m2" class="ltx_Math" alttext="G(\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></mrow></math>. Similarly, falsity of <math id="p5.m3" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> is defined as the existence of a winning strategy for the falsifier for the game <math id="p5.m4" class="ltx_Math" alttext="G(\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></mrow></math>. (A strategy is a specification that determines for each move of the opponent what the player should do. A winning strategy is a strategy which guarantees victory no matter what strategy the opponent follows.)</p>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">For classical first-order logic, this definition is equivalent to the usual Tarskian definition of truth (i.e. the one based on satisfaction found in most treatments of semantics of first-order logic). This means also that since the law of excluded middle holds for first-order logic that the games <math id="p6.m1" class="ltx_Math" alttext="G(\phi)" display="inline"><mrow><mi>G</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></mrow></math> have a very strong property: either the falsifier or the verifier has a winning strategy.</p>
</div>
<div id="p7" class="ltx_para">
<p class="ltx_p">Notice that all rules except those for negation and atomic sentences concern choosing a sentence or finding an element. These can be codified into functions, which tell us which sentence to pick or which element of the model to choose, based on our previous choices and those of our opponent. For example, consider the sentence <math id="p7.m1" class="ltx_Math" alttext="\forall x(P(x)\vee Q(x))" display="inline"><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>∨</mo><mrow><mi>Q</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. The corresponding game begins with the falsifier picking an element <math id="p7.m2" class="ltx_Math" alttext="\mathbf{a}" display="inline"><mi>𝐚</mi></math> from the model, so a strategy for the verifier must specify for each element <math id="p7.m3" class="ltx_Math" alttext="\mathbf{a}" display="inline"><mi>𝐚</mi></math> which of <math id="p7.m4" class="ltx_Math" alttext="Q(\mathbf{a})" display="inline"><mrow><mi>Q</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝐚</mi><mo stretchy="false">)</mo></mrow></mrow></math> and <math id="p7.m5" class="ltx_Math" alttext="P(\mathbf{a})" display="inline"><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝐚</mi><mo stretchy="false">)</mo></mrow></mrow></math> to pick. The truth of the sentence is equivalent to the existence of a winning strategy for the verifier, i.e. just such a function. But this means that <math id="p7.m6" class="ltx_Math" alttext="\forall x(P(x)\vee Q(x))" display="inline"><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>∨</mo><mrow><mi>Q</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math> is equivalent to <math id="p7.m7" class="ltx_Math" alttext="\exists f\forall xP(x)\wedge f(x)=0\vee Q(x)\wedge f(x)=1" display="inline"><mrow><mrow><mrow><mo>∃</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mo>∧</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mn>0</mn><mo>∨</mo><mrow><mi>Q</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>∧</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mn>1</mn></mrow></math>. Let’s consider a more complicated example: <math id="p7.m8" class="ltx_Math" alttext="\forall x\exists y\forall z\exists s\neg P(x,y,z,s)" display="inline"><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mrow><mo>∃</mo><mrow><mi>y</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>z</mi><mo>⁢</mo><mrow><mo>∃</mo><mrow><mi>s</mi><mo>⁢</mo><mi mathvariant="normal">¬</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></math>. The truth of this is equivalent to the existence of a functions <math id="p7.m9" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> and <math id="p7.m10" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math>, s.t. <math id="p7.m11" class="ltx_Math" alttext="\forall x\forall zP(x,f(x),z,g(z))" display="inline"><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>z</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi>z</mi><mo>,</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>.</p>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">These sort of functions are known as Skolem functions, and they are in essence just winning strategies for the verifier. We won’t prove it here, but all first-order sentences can be expressed in form <math id="p8.m1" class="ltx_Math" alttext="\exists f_{1}...\exists f_{n}\forall x_{1}...\forall x_{k}\phi" display="inline"><mrow><mo>∃</mo><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>⁢</mo><mi mathvariant="normal">…</mi><mo>⁢</mo><mrow><mo>∃</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo>∀</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>⁢</mo><mi mathvariant="normal">…</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>⁢</mo><mi>ϕ</mi></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></math>, where <math id="p8.m2" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> is a truth-functional combination of atomic sentences in which all terms are either constants or variables <math id="p8.m3" class="ltx_Math" alttext="x_{i}" display="inline"><msub><mi>x</mi><mi>i</mi></msub></math> or formed by application of the functions <math id="p8.m4" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> to such terms. Such sentences are said to be in <math id="p8.m5" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> form.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">Let’s consider a <math id="p9.m1" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> sentence <math id="p9.m2" class="ltx_Math" alttext="\exists f\exists g\forall x\forall z\phi(x,f(x),y,g(z))" display="inline"><mrow><mo>∃</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo>∃</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>z</mi><mo>⁢</mo><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi>y</mi><mo>,</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></math>. Up front, it seems to assert the existence of a winning strategy in a simple semantical game like those described above. However, the game can’t correspond to any (classical) first-order formula! Let’s see what such a strategy would look like. First, the falsifier chooses elements <math id="p9.m3" class="ltx_Math" alttext="\mathbf{a}" display="inline"><mi>𝐚</mi></math> and <math id="p9.m4" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math> to serve as <math id="p9.m5" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> and <math id="p9.m6" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math>. Then the verifier chooses an element <math id="p9.m7" class="ltx_Math" alttext="\mathbf{c}" display="inline"><mi>𝐜</mi></math> knowing only <math id="p9.m8" class="ltx_Math" alttext="\mathbf{a}" display="inline"><mi>𝐚</mi></math> and an element <math id="p9.m9" class="ltx_Math" alttext="\mathbf{d}" display="inline"><mi>𝐝</mi></math> knowing only <math id="p9.m10" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math>. The verifier’s goal is that <math id="p9.m11" class="ltx_Math" alttext="\phi(\mathbf{a},\mathbf{c},\mathbf{b},\mathbf{d})" display="inline"><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝐚</mi><mo>,</mo><mi>𝐜</mi><mo>,</mo><mi>𝐛</mi><mo>,</mo><mi>𝐝</mi><mo stretchy="false">)</mo></mrow></mrow></math> comes out as a true atomic sentence. The game could actually be arranged so that the verifier is a team of two players (who aren’t allowed to communicate with each other), one of which picks <math id="p9.m12" class="ltx_Math" alttext="\mathbf{c}" display="inline"><mi>𝐜</mi></math>, the other one picking <math id="p9.m13" class="ltx_Math" alttext="\mathbf{d}" display="inline"><mi>𝐝</mi></math>.</p>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">From a game-theoretical point of view, games in which some moves must be made without depending on some of the earlier moves are called “informationally incomplete” games, and they occur very commonly. Bridge is such a game, for example, and usually real examples of such games have “players” being actually teams made up of several people.</p>
</div>
<div id="p11" class="ltx_para">
<p class="ltx_p">IF-logic comes out of the game-theoretical definition in a natural way if we allow informational independence in our semantical games. In IF-logic, every connective can be augmented with an independence marker <math id="p11.m1" class="ltx_Math" alttext="//" display="inline"><mrow><mo>/</mo><mo>⁣</mo><mo>/</mo></mrow></math>, so that <math id="p11.m2" class="ltx_Math" alttext="*//*^{\prime}" display="inline"><mrow><mo>*</mo><mo>⁣</mo><mo>/</mo><mo>⁣</mo><mo>/</mo><mo>⁣</mo><msup><mo>*</mo><mo>′</mo></msup></mrow></math> means that the game for the occurrence of <math id="p11.m3" class="ltx_Math" alttext="*^{\prime}" display="inline"><msup><mo>*</mo><mo>′</mo></msup></math> within the scope of <math id="p11.m4" class="ltx_Math" alttext="*" display="inline"><mo>*</mo></math> must be played without knowledge of the choices made for <math id="p11.m5" class="ltx_Math" alttext="*" display="inline"><mo>*</mo></math>. For example <math id="p11.m6" class="ltx_Math" alttext="(\forall x//\exists y)\exists y\phi(x,y)" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>/</mo><mo>/</mo><mo>∃</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo>∃</mo><mi>y</mi><mi>ϕ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></math> asserts that for any choice of value for <math id="p11.m7" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> by the falsifier, the verifier can find a value for <math id="p11.m8" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> that does not depend on the value of <math id="p11.m9" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math>, s.t. <math id="p11.m10" class="ltx_Math" alttext="\phi(x,y)" display="inline"><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></math> comes out true. This is not a very characteristic example, as it can be written as an ordinary first-order formula <math id="p11.m11" class="ltx_Math" alttext="\exists y\forall x\phi(x,y)" display="inline"><mrow><mo>∃</mo><mrow><mi>y</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>. The curious game we described above corresponding to the second-order Skolem-function formulation <math id="p11.m12" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> sentence <math id="p11.m13" class="ltx_Math" alttext="\exists f\exists g\forall x\forall z\phi(x,f(x),y,g(z))" display="inline"><mrow><mo>∃</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo>∃</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>x</mi><mo>⁢</mo><mrow><mo>∀</mo><mrow><mi>z</mi><mo>⁢</mo><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi>y</mi><mo>,</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></math> corresponds to an IF-sentence <math id="p11.m14" class="ltx_Math" alttext="(\forall x//\exists y)(\forall z//\exists u)(\exists y)(\exists u)\phi(x,y,z,u)" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>/</mo><mo>/</mo><mo>∃</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>z</mi><mo>/</mo><mo>/</mo><mo>∃</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mo>∃</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mo>∃</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mi>ϕ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow></math>. IF-logic allows informational independence also for the usual logical connectives, for example <math id="p11.m15" class="ltx_Math" alttext="(\forall x//\vee)(\phi(x)\vee\psi(x))" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>/</mo><mo>/</mo><mo>∨</mo><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>∨</mo><mi>ψ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math> is true if and only if for all <math id="p11.m16" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math>, either <math id="p11.m17" class="ltx_Math" alttext="\phi(x)" display="inline"><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> or <math id="p11.m18" class="ltx_Math" alttext="\psi(x)" display="inline"><mrow><mi>ψ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> is true, but which of these is picked by the verifier must be decided independently of the choice for <math id="p11.m19" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> by the falsifier.</p>
</div>
<div id="p12" class="ltx_para">
<p class="ltx_p">One of the striking characteristics of IF-logic is that every <math id="p12.m1" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> formula <math id="p12.m2" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> has an IF-translation <math id="p12.m3" class="ltx_Math" alttext="\phi^{I}F" display="inline"><mrow><msup><mi>ϕ</mi><mi>I</mi></msup><mo>⁢</mo><mi>F</mi></mrow></math> which is true if and only if <math id="p12.m4" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> is true (the equivalence does not in general hold if we replace ’true’ with ’false’). Since for example first-order truth (in a model) is <math id="p12.m5" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> definable (it’s just quantification over all possible valuations, which are second-order objects), there are IF-theories which correctly represent the truth predicate for their first-order part. What is even more striking is that sufficiently strong IF-theories can do this for the <span class="ltx_text ltx_font_italic">whole</span> of the language they are expressed in.</p>
</div>
<div id="p13" class="ltx_para">
<p class="ltx_p">This seems to contradict Tarski’s famous result on the undefinability of truth, but this is illusory. Tarski’s result depends on the assumption that the logic is closed under contradictory negation. This is not the case for IF-logic. In general for a given sentence <math id="p13.m1" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> there is no sentence <math id="p13.m2" class="ltx_Math" alttext="\phi*" display="inline"><mrow><mi>ϕ</mi><mo>*</mo></mrow></math> that is true just in case <math id="p13.m3" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> is not true. Thus the law of excluded middle does not hold in general in IF-logic (although it does for the classical first-order portion). This is quite unsurprising since games of imperfect information are very seldom determined in the sense that either the verifier or the falsifier has a winning strategy. For example, a game in which I choose a 10-letter word and you have one go at guessing it is not determined in this sense, since there is no 10-letter word you couldn’t guess, and on the other hand you have no way of forcing me to choose any particular 10-letter word (which would guarantee your victory).</p>
</div>
<div id="p14" class="ltx_para">
<p class="ltx_p">IF-logic is stronger than first-order logic in the usual sense that there are classes of structures which are IF-definable but not first-order definable. Some of these are even finite. Many interesting concepts are expressible in IF-logic, such as equicardinality, infinity (which can be expressed by a logical formula in contradistinction to ordinary first-order logic in which non-logical symbols are needed), and well-ordering.</p>
</div>
<div id="p15" class="ltx_para">
<p class="ltx_p">By Lindström’s theorem we thus know that either IF-logic is not complete (i.e. its set of validities is not r.e.) or the Löwenheim-Skolem theorem does not hold. In fact, the (downward) Löwenheim-Skolem theorem <span class="ltx_text ltx_font_italic">does</span> hold for IF-logic, so it’s not complete. There is a complete disproof procedure for IF-logic, but because IF-logic is not closed under contradictory negation this does not yield a complete proof procedure.</p>
</div>
<div id="p16" class="ltx_para">
<p class="ltx_p">IF-logic can be extended by allowing contradictory negations of closed sentences and truth functional combinations thereof. This extended IF-logic is extremely strong. For example, the second-order induction axiom for PA is <math id="p16.m1" class="ltx_Math" alttext="\forall X((X(0)\wedge\forall y(X(y)\rightarrow X(y+1)))\rightarrow\forall yX(y))" display="inline"><mrow><mo>∀</mo><mi>X</mi><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mo>∧</mo><mo>∀</mo><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>X</mi><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo>→</mo><mi>X</mi><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo>→</mo><mo>∀</mo><mi>y</mi><mi>X</mi><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math>. The negation of this is a <math id="p16.m2" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> sentence asserting the existence of a set that invalidates the induction axiom. Since <math id="p16.m3" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> sentences are expressible in IF-logic, we can translate the negation of the induction axiom into IF-sentence <math id="p16.m4" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math>. But now <math id="p16.m5" class="ltx_Math" alttext="\neg\phi" display="inline"><mrow><mi mathvariant="normal">¬</mi><mo>⁢</mo><mi>ϕ</mi></mrow></math> is a formula of extended IF-logic, and is clearly equivalent to the usual induction axiom! As all the rest of PA axioms are first order, this shows that extended IF-logic PA can correctly define the natural number system.</p>
</div>
<div id="p17" class="ltx_para">
<p class="ltx_p">There exists also an interesting “translation” of <math id="p17.m1" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>th-order logic into extended IF-logic. Consider an <math id="p17.m2" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>-sorted first-order language and an <math id="p17.m3" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>th-order theory <math id="p17.m4" class="ltx_Math" alttext="T" display="inline"><mi>T</mi></math> translated into this language. Now, extend the language to second order and add the axiom stating that the sort <math id="p17.m5" class="ltx_Math" alttext="k+1" display="inline"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></math> actually comprises the whole of the powerset of the sort <math id="p17.m6" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>. This is a <math id="p17.m7" class="ltx_Math" alttext="\Pi^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Π</mi><mn>1</mn><mn>1</mn></msubsup></math> sentence (i.e. of the form “for all predicates P there is a first order element of sort <math id="p17.m8" class="ltx_Math" alttext="k+1" display="inline"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></math> that comprises exactly the <math id="p17.m9" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> extension of <math id="p17.m10" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math>”). It is easy to see that a formula is valid in this new system if and only if it was valid in the original <math id="p17.m11" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>th-order logic. The negation of this axiom is again <math id="p17.m12" class="ltx_Math" alttext="\Sigma^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> and translatable into IF-logic, and thus the axiom itself is expressible in extended IF-logic. Moreover, since most interesting second-order theories are finitely axiomatisable, we can consider sentences of form <math id="p17.m13" class="ltx_Math" alttext="T*\rightarrow\phi" display="inline"><mrow><mi>T</mi><mo>*</mo><mo>→</mo><mi>ϕ</mi></mrow></math> (where <math id="p17.m14" class="ltx_Math" alttext="T*" display="inline"><mrow><mi>T</mi><mo>*</mo></mrow></math> is the multisorted translation of <math id="p17.m15" class="ltx_Math" alttext="T" display="inline"><mi>T</mi></math>), which express logical implication of <math id="p17.m16" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math> by <math id="p17.m17" class="ltx_Math" alttext="T" display="inline"><mi>T</mi></math> (correctly). This is equivalent to <math id="p17.m18" class="ltx_Math" alttext="\neg(T*)\vee\phi" display="inline"><mrow><mi mathvariant="normal">¬</mi><mrow><mo stretchy="false">(</mo><mi>T</mi><mo>*</mo><mo stretchy="false">)</mo></mrow><mo>∨</mo><mi>ϕ</mi></mrow></math> (where <math id="p17.m19" class="ltx_Math" alttext="\neg" display="inline"><mi mathvariant="normal">¬</mi></math> is contradictory), but since <math id="p17.m20" class="ltx_Math" alttext="T*" display="inline"><mrow><mi>T</mi><mo>*</mo></mrow></math> is a conjunction of a <math id="p17.m21" class="ltx_Math" alttext="\Pi^{1}_{1}" display="inline"><msubsup><mi mathvariant="normal">Π</mi><mn>1</mn><mn>1</mn></msubsup></math>-sentence-asserting comprehension translated into extended IF-logic and first-order translation of the axioms of <math id="p17.m22" class="ltx_Math" alttext="T" display="inline"><mi>T</mi></math>, this is a <math id="p17.m23" class="ltx_Math" alttext="\Sigma_{1}^{1}" display="inline"><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mn>1</mn></msubsup></math> formula translatable to <span class="ltx_text ltx_font_italic">non</span>-extended IF-logic and so is <math id="p17.m24" class="ltx_Math" alttext="\phi" display="inline"><mi>ϕ</mi></math>. Thus sentences of form <math id="p17.m25" class="ltx_Math" alttext="T\rightarrow\phi" display="inline"><mrow><mi>T</mi><mo>→</mo><mi>ϕ</mi></mrow></math> of <math id="p17.m26" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>th-order logic are translatable into IF-sentences which are true just in case the originals were.
</p>
<table class="ltx_tabular ltx_align_right ltx_guessed_headers ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_t">Title</th>
<td class="ltx_td ltx_align_left ltx_border_r ltx_border_t">IF-logic</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Canonical name</th>
<td class="ltx_td ltx_align_left ltx_border_r">IFlogic</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Date of creation</th>
<td class="ltx_td ltx_align_left ltx_border_r">2013-03-22 13:50:46</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Last modified on</th>
<td class="ltx_td ltx_align_left ltx_border_r">2013-03-22 13:50:46</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Owner</th>
<td class="ltx_td ltx_align_left ltx_border_r">mathcam (2727)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Last modified by</th>
<td class="ltx_td ltx_align_left ltx_border_r">mathcam (2727)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Numerical id</th>
<td class="ltx_td ltx_align_left ltx_border_r">9</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Author</th>
<td class="ltx_td ltx_align_left ltx_border_r">mathcam (2727)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Entry type</th>
<td class="ltx_td ltx_align_left ltx_border_r">Definition</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Classification</th>
<td class="ltx_td ltx_align_left ltx_border_r">msc 03B99</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Synonym</th>
<td class="ltx_td ltx_align_left ltx_border_r">Independence Friendly logic</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Related topic</th>
<td class="ltx_td ltx_align_left ltx_border_r">SecondOrderLogic</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Related topic</th>
<td class="ltx_td ltx_align_left ltx_border_r">TarskisResultOnTheUndefinabilityOfTruth</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Defines</th>
<td class="ltx_td ltx_align_left ltx_border_r">IF-logic</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l">Defines</th>
<td class="ltx_td ltx_align_left ltx_border_b ltx_border_r">Independence Friendly logic</td>
</tr>
</tbody>
</table>
</div>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Feb  8 19:54:02 2018 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
