<!DOCTYPE html><html>
<head>
<title>Markov algorithm</title>
<!--Generated on Thu Feb  8 20:01:08 2018 by LaTeXML (version 0.8.2) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/3f71ceeb3b055e1ddc3b6c11fb1f074c/raw/2bb23e3b173ff96840797fc0c3bcb8c54085df8e/LaTeXML.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/4bda0365b30858ac2fb83623185fe3ec/raw/cedd84ed3e3ad597c5d293f443ecfe4803741c6b/ltx-article.css" type="text/css">
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">Markov algorithm</h1>

<div id="p1" class="ltx_para">
<br class="ltx_break">
</div>
<section id="S0.SS0.SSSx1" class="ltx_subsubsection">
<h2 class="ltx_title ltx_title_subsubsection">Definition</h2>

<div id="S0.SS0.SSSx1.p1" class="ltx_para">
<p class="ltx_p">A <em class="ltx_emph ltx_font_italic">Markov algorithm</em> is a variant of a rewriting system, invented by mathematician Andrey Andreevich Markov Jr. in 1960. Like a rewriting system, a Markov algorithm consists of an alphabet and a set of productions. Furthermore, rewriting is done by applying productions one at a time, if any. However, unlike a rewriting system, applications of productions are regulated, in the following sense:</p>
<ul id="I1" class="ltx_itemize">
<li id="I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i1.p1" class="ltx_para">
<p class="ltx_p"><math id="I1.i1.p1.m1" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math> is ordered so that, among all applicable productions in a single rewriting step, the first applicable one <math id="I1.i1.p1.m2" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math> must be used;</p>
</div>
</li>
<li id="I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i2.p1" class="ltx_para">
<p class="ltx_p">among all occurrences where rewriting can take place with respect to <math id="I1.i2.p1.m1" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math>, the leftmost occurrence must be applied.</p>
</div>
</li>
</ul>
<p class="ltx_p">Formally, a <em class="ltx_emph ltx_font_italic">Markov algorithm</em> is a quadruple <math id="S0.SS0.SSSx1.p1.m1" class="ltx_Math" alttext="\mathscr{M}=(\Sigma,P,F,T)" display="inline"><mrow><mi class="ltx_font_mathscript">ℳ</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mo>,</mo><mi>P</mi><mo>,</mo><mi>F</mi><mo>,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></mrow></math>, where</p>
<ol id="I2" class="ltx_enumerate">
<li id="I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">1.</span> 
<div id="I2.i1.p1" class="ltx_para">
<p class="ltx_p"><math id="I2.i1.p1.m1" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math> is an alphabet;</p>
</div>
</li>
<li id="I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">2.</span> 
<div id="I2.i2.p1" class="ltx_para">
<p class="ltx_p"><math id="I2.i2.p1.m1" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math> is a non-empty finite ordered set (ordered by, say, <math id="I2.i2.p1.m2" class="ltx_Math" alttext="\leq" display="inline"><mo>≤</mo></math>) of pairs of words over <math id="I2.i2.p1.m3" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math>, whose elements are called <em class="ltx_emph ltx_font_italic">productions</em>, and are usually written <math id="I2.i2.p1.m4" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math> rather than <math id="I2.i2.p1.m5" class="ltx_Math" alttext="(x,y)" display="inline"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></math>;</p>
</div>
</li>
<li id="I2.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">3.</span> 
<div id="I2.i3.p1" class="ltx_para">
<p class="ltx_p"><math id="I2.i3.p1.m1" class="ltx_Math" alttext="F" display="inline"><mi>F</mi></math> is a subset of <math id="I2.i3.p1.m2" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math>, whose elements are called the <em class="ltx_emph ltx_font_italic">final productions</em>; and</p>
</div>
</li>
<li id="I2.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">4.</span> 
<div id="I2.i4.p1" class="ltx_para">
<p class="ltx_p"><math id="I2.i4.p1.m1" class="ltx_Math" alttext="T" display="inline"><mi>T</mi></math> is a subset of <math id="I2.i4.p1.m2" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math>, called the terminal alphabet.</p>
</div>
</li>
</ol>
</div>
</section>
<section id="S0.SS0.SSSx2" class="ltx_subsubsection">
<h2 class="ltx_title ltx_title_subsubsection">Rewriting Process</h2>

<div id="S0.SS0.SSSx2.p1" class="ltx_para">
<p class="ltx_p">Next, we describe the rewriting process for <math id="S0.SS0.SSSx2.p1.m1" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math>. A production <math id="S0.SS0.SSSx2.p1.m2" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math> is <em class="ltx_emph ltx_font_italic">applicable</em> to a pair <math id="S0.SS0.SSSx2.p1.m3" class="ltx_Math" alttext="(u,v)" display="inline"><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></math> of words over <math id="S0.SS0.SSSx2.p1.m4" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math>, if there are two words <math id="S0.SS0.SSSx2.p1.m5" class="ltx_Math" alttext="p,q" display="inline"><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow></math> such that <math id="S0.SS0.SSSx2.p1.m6" class="ltx_Math" alttext="u=pxq" display="inline"><mrow><mi>u</mi><mo>=</mo><mrow><mi>p</mi><mo>⁢</mo><mi>x</mi><mo>⁢</mo><mi>q</mi></mrow></mrow></math> and <math id="S0.SS0.SSSx2.p1.m7" class="ltx_Math" alttext="v=pyq" display="inline"><mrow><mi>v</mi><mo>=</mo><mrow><mi>p</mi><mo>⁢</mo><mi>y</mi><mo>⁢</mo><mi>q</mi></mrow></mrow></math>.</p>
</div>
<div id="S0.SS0.SSSx2.p2" class="ltx_para">
<p class="ltx_p">A binary relation <math id="S0.SS0.SSSx2.p2.m1" class="ltx_Math" alttext="\Rightarrow" display="inline"><mo>⇒</mo></math> on <math id="S0.SS0.SSSx2.p2.m2" class="ltx_Math" alttext="\Sigma^{*}" display="inline"><msup><mi mathvariant="normal">Σ</mi><mo>*</mo></msup></math> called the <em class="ltx_emph ltx_font_italic">rewriting step relation</em>, is defined as follows: <math id="S0.SS0.SSSx2.p2.m3" class="ltx_Math" alttext="u\Rightarrow v" display="inline"><mrow><mi>u</mi><mo>⇒</mo><mi>v</mi></mrow></math> iff there is a production <math id="S0.SS0.SSSx2.p2.m4" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math> such that</p>
<ol id="I3" class="ltx_enumerate">
<li id="I3.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">1.</span> 
<div id="I3.i1.p1" class="ltx_para">
<p class="ltx_p"><math id="I3.i1.p1.m1" class="ltx_Math" alttext="u=pxq" display="inline"><mrow><mi>u</mi><mo>=</mo><mrow><mi>p</mi><mo>⁢</mo><mi>x</mi><mo>⁢</mo><mi>q</mi></mrow></mrow></math> and <math id="I3.i1.p1.m2" class="ltx_Math" alttext="v=pyq" display="inline"><mrow><mi>v</mi><mo>=</mo><mrow><mi>p</mi><mo>⁢</mo><mi>y</mi><mo>⁢</mo><mi>q</mi></mrow></mrow></math> for some words <math id="I3.i1.p1.m3" class="ltx_Math" alttext="p,q" display="inline"><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow></math> over <math id="I3.i1.p1.m4" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math>,</p>
</div>
</li>
<li id="I3.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">2.</span> 
<div id="I3.i2.p1" class="ltx_para">
<p class="ltx_p">if <math id="I3.i2.p1.m1" class="ltx_Math" alttext="(r,s)&lt;(x,y)" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><mo>&lt;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></math>, then <math id="I3.i2.p1.m2" class="ltx_Math" alttext="r\to s" display="inline"><mrow><mi>r</mi><mo>→</mo><mi>s</mi></mrow></math> is not applicable to <math id="I3.i2.p1.m3" class="ltx_Math" alttext="(u,v)" display="inline"><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></math>,</p>
</div>
</li>
<li id="I3.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">3.</span> 
<div id="I3.i3.p1" class="ltx_para">
<p class="ltx_p">if <math id="I3.i3.p1.m1" class="ltx_Math" alttext="u=p^{\prime}xq^{\prime}" display="inline"><mrow><mi>u</mi><mo>=</mo><mrow><msup><mi>p</mi><mo>′</mo></msup><mo>⁢</mo><mi>x</mi><mo>⁢</mo><msup><mi>q</mi><mo>′</mo></msup></mrow></mrow></math> and <math id="I3.i3.p1.m2" class="ltx_Math" alttext="v=p^{\prime}yq^{\prime}" display="inline"><mrow><mi>v</mi><mo>=</mo><mrow><msup><mi>p</mi><mo>′</mo></msup><mo>⁢</mo><mi>y</mi><mo>⁢</mo><msup><mi>q</mi><mo>′</mo></msup></mrow></mrow></math>, then <math id="I3.i3.p1.m3" class="ltx_Math" alttext="px" display="inline"><mrow><mi>p</mi><mo>⁢</mo><mi>x</mi></mrow></math> is a prefix of <math id="I3.i3.p1.m4" class="ltx_Math" alttext="p^{\prime}x" display="inline"><mrow><msup><mi>p</mi><mo>′</mo></msup><mo>⁢</mo><mi>x</mi></mrow></math>.</p>
</div>
</li>
</ol>
<p class="ltx_p">The first condition ensures that there is a production (<math id="S0.SS0.SSSx2.p2.m5" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math> in this case) applicable to <math id="S0.SS0.SSSx2.p2.m6" class="ltx_Math" alttext="(u,v)" display="inline"><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></math>, the second condition says that <math id="S0.SS0.SSSx2.p2.m7" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math> is the first available production that can be applied, and the last condition says that the occurrence of <math id="S0.SS0.SSSx2.p2.m8" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> in <math id="S0.SS0.SSSx2.p2.m9" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math> is the leftmost.</p>
</div>
<div id="S0.SS0.SSSx2.p3" class="ltx_para">
<p class="ltx_p">By the definition above, every rewriting step <math id="S0.SS0.SSSx2.p3.m1" class="ltx_Math" alttext="u\Rightarrow v" display="inline"><mrow><mi>u</mi><mo>⇒</mo><mi>v</mi></mrow></math> determines a unique production <math id="S0.SS0.SSSx2.p3.m2" class="ltx_Math" alttext="x\to y" display="inline"><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow></math>, called the <em class="ltx_emph ltx_font_italic">associated production</em> of <math id="S0.SS0.SSSx2.p3.m3" class="ltx_Math" alttext="u\Rightarrow v" display="inline"><mrow><mi>u</mi><mo>⇒</mo><mi>v</mi></mrow></math>.</p>
</div>
<div id="S0.SS0.SSSx2.p4" class="ltx_para">
<p class="ltx_p">A word <math id="S0.SS0.SSSx2.p4.m1" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math> over <math id="S0.SS0.SSSx2.p4.m2" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math> is said to be <em class="ltx_emph ltx_font_italic">terminal</em> if there are no words <math id="S0.SS0.SSSx2.p4.m3" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> such that <math id="S0.SS0.SSSx2.p4.m4" class="ltx_Math" alttext="u\Rightarrow v" display="inline"><mrow><mi>u</mi><mo>⇒</mo><mi>v</mi></mrow></math>.</p>
</div>
<div id="S0.SS0.SSSx2.p5" class="ltx_para">
<p class="ltx_p">A rewriting step is called <em class="ltx_emph ltx_font_italic">final</em> if its associated production is final (in <math id="S0.SS0.SSSx2.p5.m1" class="ltx_Math" alttext="F" display="inline"><mi>F</mi></math>).
</p>
</div>
</section>
<section id="S0.SS0.SSSx3" class="ltx_subsubsection">
<h2 class="ltx_title ltx_title_subsubsection">Computation</h2>

<div id="S0.SS0.SSSx3.p1" class="ltx_para">
<p class="ltx_p">Take the reflexive transitive closure <math id="S0.SS0.SSSx3.p1.m1" class="ltx_Math" alttext="\Rightarrow^{*}" display="inline"><msup><mo>⇒</mo><mo>*</mo></msup></math> of <math id="S0.SS0.SSSx3.p1.m2" class="ltx_Math" alttext="\Rightarrow" display="inline"><mo>⇒</mo></math>. If <math id="S0.SS0.SSSx3.p1.m3" class="ltx_Math" alttext="u\Rightarrow^{*}v" display="inline"><mrow><mi>u</mi><msup><mo>⇒</mo><mo>*</mo></msup><mi>v</mi></mrow></math>, we say that <math id="S0.SS0.SSSx3.p1.m4" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> can be <em class="ltx_emph ltx_font_italic">computed</em> from <math id="S0.SS0.SSSx3.p1.m5" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>, or that <math id="S0.SS0.SSSx3.p1.m6" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> is a <em class="ltx_emph ltx_font_italic">computation</em> from <math id="S0.SS0.SSSx3.p1.m7" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>.</p>
</div>
<div id="S0.SS0.SSSx3.p2" class="ltx_para">
<p class="ltx_p">Given any word <math id="S0.SS0.SSSx3.p2.m1" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math> over <math id="S0.SS0.SSSx3.p2.m2" class="ltx_Math" alttext="\Sigma" display="inline"><mi mathvariant="normal">Σ</mi></math>, we may iteratively apply rewriting steps to <math id="S0.SS0.SSSx3.p2.m3" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math> using the methods described above. Three scenarios may emerge:</p>
<ul id="I4" class="ltx_itemize">
<li id="I4.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I4.i1.p1" class="ltx_para">
<p class="ltx_p">The process terminates: <math id="I4.i1.p1.m1" class="ltx_Math" alttext="u\Rightarrow^{*}v" display="inline"><mrow><mi>u</mi><msup><mo>⇒</mo><mo>*</mo></msup><mi>v</mi></mrow></math>, where <math id="I4.i1.p1.m2" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> is a terminal word;</p>
</div>
</li>
<li id="I4.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I4.i2.p1" class="ltx_para">
<p class="ltx_p">The process reaches a final rewriting step: <math id="I4.i2.p1.m1" class="ltx_Math" alttext="u\Rightarrow^{*}v" display="inline"><mrow><mi>u</mi><msup><mo>⇒</mo><mo>*</mo></msup><mi>v</mi></mrow></math>, where the last rewriting step <math id="I4.i2.p1.m2" class="ltx_Math" alttext="u_{n-1}\Rightarrow u_{n}=v" display="inline"><mrow><msub><mi>u</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>⇒</mo><msub><mi>u</mi><mi>n</mi></msub><mo>=</mo><mi>v</mi></mrow></math> is final; or</p>
</div>
</li>
<li id="I4.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I4.i3.p1" class="ltx_para">
<p class="ltx_p">The process never reaches any final rewriting step, and goes on indefinitely.</p>
</div>
</li>
</ul>
</div>
<div id="S0.SS0.SSSx3.p3" class="ltx_para">
<p class="ltx_p">If the third scenario occurs, we say that <math id="S0.SS0.SSSx3.p3.m1" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> <em class="ltx_emph ltx_font_italic">loops</em> on <math id="S0.SS0.SSSx3.p3.m2" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>. Otherwise, <math id="S0.SS0.SSSx3.p3.m3" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> <em class="ltx_emph ltx_font_italic">halts</em> on <math id="S0.SS0.SSSx3.p3.m4" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>. In any case, we get a unique sequence</p>
<table id="S0.Ex1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex1.m1" class="ltx_Math" alttext="u=u_{0}\Rightarrow u_{1}\Rightarrow\cdots\Rightarrow u_{n}\Rightarrow\cdots" display="block"><mrow><mi>u</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mo>⇒</mo><msub><mi>u</mi><mn>1</mn></msub><mo>⇒</mo><mi mathvariant="normal">⋯</mi><mo>⇒</mo><msub><mi>u</mi><mi>n</mi></msub><mo>⇒</mo><mi mathvariant="normal">⋯</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">of rewriting steps <math id="S0.SS0.SSSx3.p3.m5" class="ltx_Math" alttext="u_{i}\to u_{i+1}" display="inline"><mrow><msub><mi>u</mi><mi>i</mi></msub><mo>→</mo><msub><mi>u</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>. In the first scenario, the sequence is finite, and in the third scenario, the sequence is infinite. In the second scenario, the sequence may be finite or infinite, depending if the rewriting is to be continued after a final rewriting step is reached (if <math id="S0.SS0.SSSx3.p3.m6" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> is not a terminal word, then rewriting can continue). Let us make the rule:</p>
<blockquote class="ltx_quote">
<p class="ltx_p">when a final rewriting is reached, no further rewriting is to be done.</p>
</blockquote>
<p class="ltx_p">Thus, the sequence is finite iff <math id="S0.SS0.SSSx3.p3.m7" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> halts on <math id="S0.SS0.SSSx3.p3.m8" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>. When <math id="S0.SS0.SSSx3.p3.m9" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> halts on <math id="S0.SS0.SSSx3.p3.m10" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>, the finite sequence</p>
<table id="S0.Ex2" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex2.m1" class="ltx_Math" alttext="u=u_{0}\Rightarrow u_{1}\Rightarrow\cdots\Rightarrow u_{n}=v" display="block"><mrow><mi>u</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mo>⇒</mo><msub><mi>u</mi><mn>1</mn></msub><mo>⇒</mo><mi mathvariant="normal">⋯</mi><mo>⇒</mo><msub><mi>u</mi><mi>n</mi></msub><mo>=</mo><mi>v</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">produces a unique word <math id="S0.SS0.SSSx3.p3.m11" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math>. The word <math id="S0.SS0.SSSx3.p3.m12" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> is said to be <em class="ltx_emph ltx_font_italic">the word computed by</em> <math id="S0.SS0.SSSx3.p3.m13" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> from <math id="S0.SS0.SSSx3.p3.m14" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>. Notice that <math id="S0.SS0.SSSx3.p3.m15" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> is either a terminal word, or is computed from a final production <math id="S0.SS0.SSSx3.p3.m16" class="ltx_Math" alttext="u_{n-1}\to v" display="inline"><mrow><msub><mi>u</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>→</mo><mi>v</mi></mrow></math>. In either case, no earlier productions <math id="S0.SS0.SSSx3.p3.m17" class="ltx_Math" alttext="u_{i}\to u_{i+1}" display="inline"><mrow><msub><mi>u</mi><mi>i</mi></msub><mo>→</mo><msub><mi>u</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math> are final.</p>
</div>
<div id="S0.SS0.SSSx3.p4" class="ltx_para">
<p class="ltx_p">Thus, one can think of a computation by a Markov algorithm as a partial function</p>
<table id="S0.Ex3" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex3.m1" class="ltx_Math" alttext="m_{\mathscr{M}}:\Sigma^{*}\to\Sigma^{*}," display="block"><mrow><mrow><msub><mi>m</mi><mi class="ltx_font_mathscript">ℳ</mi></msub><mo>:</mo><mrow><msup><mi mathvariant="normal">Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi mathvariant="normal">Σ</mi><mo>*</mo></msup></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where <math id="S0.SS0.SSSx3.p4.m1" class="ltx_Math" alttext="m_{\mathscr{M}}(u)" display="inline"><mrow><msub><mi>m</mi><mi class="ltx_font_mathscript">ℳ</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow></math> is defined iff <math id="S0.SS0.SSSx3.p4.m2" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> halts on <math id="S0.SS0.SSSx3.p4.m3" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>, and the value <math id="S0.SS0.SSSx3.p4.m4" class="ltx_Math" alttext="m_{\mathscr{M}}(u)" display="inline"><mrow><msub><mi>m</mi><mi class="ltx_font_mathscript">ℳ</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow></math> is set to <em class="ltx_emph ltx_font_italic">the unique word</em> <math id="S0.SS0.SSSx3.p4.m5" class="ltx_Math" alttext="v" display="inline"><mi>v</mi></math> computed by <math id="S0.SS0.SSSx3.p4.m6" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> from <math id="S0.SS0.SSSx3.p4.m7" class="ltx_Math" alttext="u" display="inline"><mi>u</mi></math>.</p>
</div>
</section>
<section id="S0.SS0.SSSx4" class="ltx_subsubsection">
<h2 class="ltx_title ltx_title_subsubsection">Language Acceptor</h2>

<div id="S0.SS0.SSSx4.p1" class="ltx_para">
<p class="ltx_p"><math id="S0.SS0.SSSx4.p1.m1" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> can be thought of as a language acceptor, which is the purpose of the terminal alphabet <math id="S0.SS0.SSSx4.p1.m2" class="ltx_Math" alttext="T" display="inline"><mi>T</mi></math>: the set</p>
<table id="S0.Ex4" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex4.m1" class="ltx_Math" alttext="L(\mathscr{M}):=\{u\in T^{*}\mid m_{\mathscr{M}}(u)=\lambda\}" display="block"><mrow><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi class="ltx_font_mathscript">ℳ</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>u</mi><mo>∈</mo><msup><mi>T</mi><mo>*</mo></msup></mrow><mo>∣</mo><mrow><mrow><msub><mi>m</mi><mi class="ltx_font_mathscript">ℳ</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>λ</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">is called the <em class="ltx_emph ltx_font_italic">language accepted by</em> <math id="S0.SS0.SSSx4.p1.m3" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math>. The partial function <math id="S0.SS0.SSSx4.p1.m4" class="ltx_Math" alttext="m_{\mathscr{M}}" display="inline"><msub><mi>m</mi><mi class="ltx_font_mathscript">ℳ</mi></msub></math> is defined in the previous section.</p>
</div>
<div id="S0.SS0.SSSx4.p2" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_bold">Remark</span>. It turns out that a Markov algorithm is just another form of Turing Machine. One can show that a language is recursively enumerable iff it can be accepted by a Markov algorithm.</p>
</div>
<div id="S0.SS0.SSSx4.p3" class="ltx_para">
<p class="ltx_p">Equivalence to a Turing machine can be restated in terms of functional computability. Before formalizing this notion, we need to first encode tuples of natural numbers by words. Suppose <math id="S0.SS0.SSSx4.p3.m1" class="ltx_Math" alttext="(n_{1},\ldots,n_{m})" display="inline"><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></math> is an <math id="S0.SS0.SSSx4.p3.m2" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math>-tuple of natural numbers. Set</p>
<table id="S0.Ex5" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex5.m1" class="ltx_Math" alttext="E(n_{1},\ldots,n_{m}):=ab^{n_{1}}ab^{n_{2}}a\cdots ab^{n_{m}}a," display="block"><mrow><mrow><mrow><mi>E</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>:=</mo><mrow><mi>a</mi><mo>⁢</mo><msup><mi>b</mi><msub><mi>n</mi><mn>1</mn></msub></msup><mo>⁢</mo><mi>a</mi><mo>⁢</mo><msup><mi>b</mi><msub><mi>n</mi><mn>2</mn></msub></msup><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi mathvariant="normal">⋯</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><msup><mi>b</mi><msub><mi>n</mi><mi>m</mi></msub></msup><mo>⁢</mo><mi>a</mi></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">a word over the alphabet <math id="S0.SS0.SSSx4.p3.m3" class="ltx_Math" alttext="\{a,b\}" display="inline"><mrow><mo stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">}</mo></mrow></math>. If non-negative integers are allowed instead, we may use the word <math id="S0.SS0.SSSx4.p3.m4" class="ltx_Math" alttext="E(n_{1}+1,\ldots,n_{m}+1)" display="inline"><mrow><mi>E</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><msub><mi>n</mi><mi>m</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></math> instead.</p>
</div>
<div id="S0.SS0.SSSx4.p4" class="ltx_para">
<p class="ltx_p">We say an <math id="S0.SS0.SSSx4.p4.m1" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math>-ary number-theoretic partial function <math id="S0.SS0.SSSx4.p4.m2" class="ltx_Math" alttext="f:\mathbb{N}^{m}\to\mathbb{N}" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><msup><mi>ℕ</mi><mi>m</mi></msup><mo>→</mo><mi>ℕ</mi></mrow></mrow></math> is <em class="ltx_emph ltx_font_italic">Markov-computable</em> if there is a Markov algorithm <math id="S0.SS0.SSSx4.p4.m3" class="ltx_Math" alttext="\mathscr{M}" display="inline"><mi class="ltx_font_mathscript">ℳ</mi></math> such that <math id="S0.SS0.SSSx4.p4.m4" class="ltx_Math" alttext="f(n_{1},\ldots,n_{m})" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> is defined iff <math id="S0.SS0.SSSx4.p4.m5" class="ltx_Math" alttext="m_{\mathscr{M}}(E(n_{1},\ldots,n_{m}))" display="inline"><mrow><msub><mi>m</mi><mi class="ltx_font_mathscript">ℳ</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math> is defined, and is equal to <math id="S0.SS0.SSSx4.p4.m6" class="ltx_Math" alttext="E(f(n_{1},\ldots,n_{m}))" display="inline"><mrow><mi>E</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p>
</div>
<div id="S0.SS0.SSSx4.p5" class="ltx_para">
<p class="ltx_p">It can be shown that a partial function is Turing-computable iff it is Markov-computable.</p>
</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul class="ltx_biblist">
      
<li id="bib.bib1" class="ltx_bibitem">
        <span class="ltx_bibtag ltx_role_refnum">1</span>
        
<span class="ltx_bibblock"> A. Salomaa <span class="ltx_text ltx_font_italic">Computation and Automata, Encyclopedia of Mathematics and Its Applications, Vol. 25</span>. Cambridge (1985).

</span>
      </li>
      
<li id="bib.bib2" class="ltx_bibitem">
        <span class="ltx_bibtag ltx_role_refnum">2</span>
        
<span class="ltx_bibblock"> N. Cutland, <span class="ltx_text ltx_font_italic">Computability: An Introduction to Recursive Function Theory</span>. Cambridge University Press, (1980).

</span>
      </li>
      
<li id="bib.bib3" class="ltx_bibitem">
        <span class="ltx_bibtag ltx_role_refnum">3</span>
        
<span class="ltx_bibblock"> J. D. Monk, <em class="ltx_emph ltx_font_italic">Mathematical Logic</em>, Springer, New York (1976).

</span>
      </li>
    
</ul>
</section>
<div id="p2" class="ltx_para ltx_align_right">
<table class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_t">Title</th>
<td class="ltx_td ltx_align_left ltx_border_r ltx_border_t">Markov algorithm</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Canonical name</th>
<td class="ltx_td ltx_align_left ltx_border_r">MarkovAlgorithm</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Date of creation</th>
<td class="ltx_td ltx_align_left ltx_border_r">2013-03-22 18:57:50</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Last modified on</th>
<td class="ltx_td ltx_align_left ltx_border_r">2013-03-22 18:57:50</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Owner</th>
<td class="ltx_td ltx_align_left ltx_border_r">CWoo (3771)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Last modified by</th>
<td class="ltx_td ltx_align_left ltx_border_r">CWoo (3771)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Numerical id</th>
<td class="ltx_td ltx_align_left ltx_border_r">13</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Author</th>
<td class="ltx_td ltx_align_left ltx_border_r">CWoo (3771)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Entry type</th>
<td class="ltx_td ltx_align_left ltx_border_r">Definition</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Classification</th>
<td class="ltx_td ltx_align_left ltx_border_r">msc 03D10</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l">Defines</th>
<td class="ltx_td ltx_align_left ltx_border_b ltx_border_r">Markov-computable</td>
</tr>
</tbody>
</table>
<p class="ltx_p"></p>
</div>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Feb  8 20:01:08 2018 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
