<!DOCTYPE html><html>
<head>
<title>6.2 Induction principles and dependent paths</title>
<!--Generated on Thu Feb  8 19:37:58 2018 by LaTeXML (version 0.8.2) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/3f71ceeb3b055e1ddc3b6c11fb1f074c/raw/2bb23e3b173ff96840797fc0c3bcb8c54085df8e/LaTeXML.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/4bda0365b30858ac2fb83623185fe3ec/raw/cedd84ed3e3ad597c5d293f443ecfe4803741c6b/ltx-article.css" type="text/css">
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML" type="text/javascript"></script>
<meta name="keywords" lang="en" content=", , , axiom, circle, computation rule, definitional, dependent, equality, for , for higher inductive types, function, truncated, heterogeneous, heterogeneous equality, induction principle, judgmental, judgmental equality, of , path, predecessor, property, propositional, recursion principle, rule, type, universal, vary along a path constructor, versus axioms, versus rules">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">6.2 Induction principles and dependent paths</h1>

<div id="p1" class="ltx_para">
<br class="ltx_break">
<p class="ltx_p">When we describe a <a class="nnexus_concept" href="http://planetmath.org/higherinductivetypes">higher inductive type</a> such as the circle as being generated by certain constructors, we have to explain what this means by giving rules analogous to those for the basic type constructors from <span class="ltx_text ltx_font_typewriter">http://planetmath.org/node/87533</span>Chapter 1.
The constructors themselves give the <em class="ltx_emph ltx_font_italic"><a class="nnexus_concept" href="http://planetmath.org/introduction">introduction</a></em> rules, but it requires a bit more thought to explain the <em class="ltx_emph ltx_font_italic">elimination</em> rules, i.e. the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">induction</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Induction.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/induction"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> and <a class="nnexus_concept" href="http://mathworld.wolfram.com/Recursion.html">recursion</a> principles.
In this book we do not attempt to give a general formulation of what constitutes a “higher inductive definition” and how to extract the elimination rule from such a definition — indeed, this is a subtle question and the subject of current research.
Instead we will rely on some general informal discussion and numerous examples.</p>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">The recursion principle is usually easy to describe: given any type equipped with the same <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">structure</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Structure.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/structure"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> with which the constructors equip the higher inductive type in question, there is a <a class="nnexus_concept" href="http://planetmath.org/function">function</a> which maps the constructors to that structure.
For <a class="nnexus_concept" href="http://planetmath.org/substitutionsinpropositionallogic">instance</a>, in the case of <math id="p2.m1" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math>, the recursion principle says that given any type <math id="p2.m2" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math> equipped with a point <math id="p2.m3" class="ltx_Math" alttext="b:B" display="inline"><mrow><mi>b</mi><mo>:</mo><mi>B</mi></mrow></math> and a path <math id="p2.m4" class="ltx_Math" alttext="\ell:b=b" display="inline"><mrow><mi mathvariant="normal">ℓ</mi><mo>:</mo><mrow><mi>b</mi><mo>=</mo><mi>b</mi></mrow></mrow></math>, there is a function <math id="p2.m5" class="ltx_Math" alttext="f:\mathbb{S}^{1}\to B" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi>B</mi></mrow></mrow></math> such that <math id="p2.m6" class="ltx_Math" alttext="f(\mathsf{base})=b" display="inline"><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>b</mi></mrow></math> and <math id="p2.m7" class="ltx_Math" alttext="\mathsf{ap}_{f}(\mathsf{loop})=\ell" display="inline"><mrow><mrow><msub><mi>𝖺𝗉</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi mathvariant="normal">ℓ</mi></mrow></math>.</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">The latter two <a class="nnexus_concept" href="http://planetmath.org/equality">equalities</a> are the <em class="ltx_emph ltx_font_italic"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Computation.html">computation</a> rules</em>.
There is, however, a question of whether these computation rules are judgmental equalities or propositional equalities (paths).
For ordinary inductive types, we had no qualms about making them judgmental, although we saw in <span class="ltx_text ltx_font_typewriter">http://planetmath.org/node/87578</span>Chapter 5 that making them propositional would still yield the same type up to equivalence.
In the ordinary case, one may argue that the computation rules are really <em class="ltx_emph ltx_font_italic">definitional</em> equalities, in the intuitive sense described in the Introduction.</p>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">For higher inductive types, this is less clear. Moreover, since the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">operation</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Operation.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/operation"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> <math id="p4.m1" class="ltx_Math" alttext="\mathsf{ap}_{f}" display="inline"><msub><mi>𝖺𝗉</mi><mi>f</mi></msub></math> is not really a fundamental part of the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">type theory</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/typetheory"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/russellstheoryoftypes"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, but something that we <em class="ltx_emph ltx_font_italic">defined</em> using the induction principle of identity types (and which we might have defined in some other, <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">equivalent</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Equivalent.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/filterbasis"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/equivalenceofforcingnotions"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/equivalentmachines"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/equivalencerelation"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, way), it seems inappropriate to refer to it explicitly in a <em class="ltx_emph ltx_font_italic">judgmental</em> equality.
Judgmental equalities are part of the <a class="nnexus_concept" href="http://planetmath.org/deductivesystem">deductive system</a>, which should not depend on particular choices of definitions that we may make <em class="ltx_emph ltx_font_italic">within</em> that system.
There are also <a class="nnexus_concept" href="http://planetmath.org/logic">semantic</a> and implementation issues to consider; see the Notes (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/chapter6notes</span>).</p>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">It does seem unproblematic to make the computational rules for the <em class="ltx_emph ltx_font_italic">point</em> constructors of a higher inductive type judgmental.
In the example above, this means we have <math id="p5.m1" class="ltx_Math" alttext="f(\mathsf{base})\equiv b" display="inline"><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≡</mo><mi>b</mi></mrow></math>, judgmentally.
This choice facilitates a computational view of higher inductive types.
Moreover, it also greatly simplifies our lives, since otherwise the second computation rule <math id="p5.m2" class="ltx_Math" alttext="\mathsf{ap}_{f}(\mathsf{loop})=\ell" display="inline"><mrow><mrow><msub><mi>𝖺𝗉</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi mathvariant="normal">ℓ</mi></mrow></math> would not even be well-typed as a propositional equality; we would have to compose one side or the other with the specified identification of <math id="p5.m3" class="ltx_Math" alttext="f(\mathsf{base})" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></math> with <math id="p5.m4" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math>.
(Such problems do arise <a class="nnexus_concept" href="http://planetmath.org/eventualproperty">eventually</a>, of course, when we come to talk about paths of higher <a class="nnexus_concept" href="http://planetmath.org/dimensionofaposet">dimension</a>, but that will not be of great concern to us here.
See also §6.7 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/67hubsandspokes</span>).)
Thus, we take the computation rules for point constructors to be judgmental, and those for paths and higher paths to be propositional.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup>In particular, in the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">language</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/language"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/signature"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> of §1.1 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/11typetheoryversussettheory</span>), this means that our higher inductive types are a mix of <em class="ltx_emph ltx_font_italic">rules</em> (specifying how we can introduce such types and their <a class="nnexus_concept" href="http://mathworld.wolfram.com/Element.html">elements</a>, their induction principle, and their computation rules for point constructors) and <em class="ltx_emph ltx_font_italic">axioms</em> (the computation rules for path constructors, which assert that certain identity types are inhabited by otherwise unspecified terms).
We may hope that eventually, there will be a better type theory in which higher inductive types, like univalence, will be presented using only rules and no axioms.</span></span></span></p>
</div>
<div id="Thmprermk1" class="ltx_theorem ltx_theorem_prermk">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Remark 6.2.1</span>.</h6>
<div id="Thmprermk1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">Recall that for ordinary inductive types, we regard the computation rules for a recursively defined function as not merely judgmental equalities, but <em class="ltx_emph ltx_font_upright">definitional</em> ones, and thus we may use the notation <math id="Thmprermk1.p1.m1" class="ltx_Math" alttext=":\!\!\equiv" display="inline"><mrow><mi></mi><mo mathvariant="normal" rspace="0pt">:</mo><mo mathvariant="normal">≡</mo></mrow></math> for them.
For instance, the truncated <a class="nnexus_concept" href="http://mathworld.wolfram.com/Predecessor.html">predecessor</a> function <math id="Thmprermk1.p1.m2" class="ltx_Math" alttext="p:\mathbb{N}\to\mathbb{N}" display="inline"><mrow><mi>p</mi><mo mathvariant="normal">:</mo><mrow><mi mathvariant="normal">N</mi><mo mathvariant="normal">→</mo><mi mathvariant="normal">N</mi></mrow></mrow></math> is defined by <math id="Thmprermk1.p1.m3" class="ltx_Math" alttext="p(0):\!\!\equiv 0" display="inline"><mrow><mi>p</mi><mrow><mo mathvariant="normal" stretchy="false">(</mo><mn mathvariant="normal">0</mn><mo mathvariant="normal" stretchy="false">)</mo></mrow><mo mathvariant="normal" rspace="0pt">:</mo><mo mathvariant="normal">≡</mo><mn mathvariant="normal">0</mn></mrow></math> and <math id="Thmprermk1.p1.m4" class="ltx_Math" alttext="p(\mathsf{succ}(n)):\!\!\equiv n" display="inline"><mrow><mi>p</mi><mrow><mo mathvariant="normal" stretchy="false">(</mo><mi mathvariant="normal">succ</mi><mrow><mo mathvariant="normal" stretchy="false">(</mo><mi>n</mi><mo mathvariant="normal" stretchy="false">)</mo></mrow><mo mathvariant="normal" stretchy="false">)</mo></mrow><mo mathvariant="normal" rspace="0pt">:</mo><mo mathvariant="normal">≡</mo><mi>n</mi></mrow></math>.
In the case of higher inductive types, this sort of notation is reasonable for the point constructors (e.g. <math id="Thmprermk1.p1.m5" class="ltx_Math" alttext="f(\mathsf{base}):\!\!\equiv b" display="inline"><mrow><mi>f</mi><mrow><mo mathvariant="normal" stretchy="false">(</mo><mi mathvariant="normal">base</mi><mo mathvariant="normal" stretchy="false">)</mo></mrow><mo mathvariant="normal" rspace="0pt">:</mo><mo mathvariant="normal">≡</mo><mi>b</mi></mrow></math>), but for the path constructors it could be misleading, since equalities such as <math id="Thmprermk1.p1.m6" class="ltx_Math" alttext="{f}\mathopen{}\left({\mathsf{loop}}\right)\mathclose{}=\ell" display="inline"><mrow><mi>f</mi><mrow><mi></mi><mrow><mo mathvariant="normal">(</mo><mi mathvariant="normal">loop</mi><mo mathvariant="normal">)</mo></mrow><mi></mi></mrow><mo mathvariant="normal">=</mo><mi mathvariant="normal">ℓ</mi></mrow></math> are not judgmental.
Thus, we hybridize the notations, writing instead <math id="Thmprermk1.p1.m7" class="ltx_Math" alttext="{f}\mathopen{}\left({\mathsf{loop}}\right)\mathclose{}:=\ell" display="inline"><mrow><mi>f</mi><mrow><mi></mi><mrow><mo mathvariant="normal">(</mo><mi mathvariant="normal">loop</mi><mo mathvariant="normal">)</mo></mrow><mi></mi></mrow><mo mathvariant="normal">:=</mo><mi mathvariant="normal">ℓ</mi></mrow></math> for this sort of “propositional equality by definition”.</span></p>
</div>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">Now, what about the induction principle (the dependent eliminator)?
Recall that for an ordinary inductive type <math id="p6.m1" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>, to prove by induction that <math id="p6.m2" class="ltx_Math" alttext="\mathchoice{\prod_{x:W}\,}{\mathchoice{{\textstyle\prod_{(x:W)}}}{\prod_{(x:W)%
}}{\prod_{(x:W)}}{\prod_{(x:W)}}}{\mathchoice{{\textstyle\prod_{(x:W)}}}{\prod%
_{(x:W)}}{\prod_{(x:W)}}{\prod_{(x:W)}}}{\mathchoice{{\textstyle\prod_{(x:W)}}%
}{\prod_{(x:W)}}{\prod_{(x:W)}}{\prod_{(x:W)}}}P(x)" display="inline"><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>W</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, we must specify, for each constructor of <math id="p6.m3" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>, an operation on <math id="p6.m4" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math> which acts on the “fibers” above that constructor in <math id="p6.m5" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>.
For instance, if <math id="p6.m6" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math> is the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">natural numbers</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/NaturalNumber.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/naturalnumber"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> <math id="p6.m7" class="ltx_Math" alttext="\mathbb{N}" display="inline"><mi>ℕ</mi></math>, then to prove by induction that <math id="p6.m8" class="ltx_Math" alttext="\mathchoice{\prod_{x:\mathbb{N}}\,}{\mathchoice{{\textstyle\prod_{(x:\mathbb{N%
})}}}{\prod_{(x:\mathbb{N})}}{\prod_{(x:\mathbb{N})}}{\prod_{(x:\mathbb{N})}}}%
{\mathchoice{{\textstyle\prod_{(x:\mathbb{N})}}}{\prod_{(x:\mathbb{N})}}{\prod%
_{(x:\mathbb{N})}}{\prod_{(x:\mathbb{N})}}}{\mathchoice{{\textstyle\prod_{(x:%
\mathbb{N})}}}{\prod_{(x:\mathbb{N})}}{\prod_{(x:\mathbb{N})}}{\prod_{(x:%
\mathbb{N})}}}P(x)" display="inline"><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>ℕ</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, we must specify</p>
<ul id="I1" class="ltx_itemize">
<li id="I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i1.p1" class="ltx_para">
<p class="ltx_p">An element <math id="I1.i1.p1.m1" class="ltx_Math" alttext="b:P(0)" display="inline"><mrow><mi>b</mi><mo>:</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></math> in the fiber over the constructor <math id="I1.i1.p1.m2" class="ltx_Math" alttext="0:\mathbb{N}" display="inline"><mrow><mn>0</mn><mo>:</mo><mi>ℕ</mi></mrow></math>, and</p>
</div>
</li>
<li id="I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i2.p1" class="ltx_para">
<p class="ltx_p">For each <math id="I1.i2.p1.m1" class="ltx_Math" alttext="n:\mathbb{N}" display="inline"><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi></mrow></math>, a function <math id="I1.i2.p1.m2" class="ltx_Math" alttext="P(n)\to P(\mathsf{succ}(n))" display="inline"><mrow><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>→</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>𝗌𝗎𝖼𝖼</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</p>
</div>
</li>
</ul>
<p class="ltx_p">The second can be viewed as a function “<math id="p6.m9" class="ltx_Math" alttext="P\to P" display="inline"><mrow><mi>P</mi><mo>→</mo><mi>P</mi></mrow></math>” lying <em class="ltx_emph ltx_font_italic">over</em> the constructor <math id="p6.m10" class="ltx_Math" alttext="\mathsf{succ}:\mathbb{N}\to\mathbb{N}" display="inline"><mrow><mi>𝗌𝗎𝖼𝖼</mi><mo>:</mo><mrow><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow></mrow></math>, generalizing how <math id="p6.m11" class="ltx_Math" alttext="b:P(0)" display="inline"><mrow><mi>b</mi><mo>:</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></math> lies over the constructor <math id="p6.m12" class="ltx_Math" alttext="0:\mathbb{N}" display="inline"><mrow><mn>0</mn><mo>:</mo><mi>ℕ</mi></mrow></math>.</p>
</div>
<div id="p7" class="ltx_para">
<p class="ltx_p">By <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">analogy</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Analogy.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/similarityandanalogoussystemsdynamicadjointnessandtopologicalequivalence"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup>, therefore, to prove that <math id="p7.m1" class="ltx_Math" alttext="\mathchoice{\prod_{x:\mathbb{S}^{1}}\,}{\mathchoice{{\textstyle\prod_{(x:%
\mathbb{S}^{1})}}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{%
\prod_{(x:\mathbb{S}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S}^{1})}%
}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S%
}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S}^{1})}}}{\prod_{(x:%
\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}}P(x)" display="inline"><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo stretchy="false">)</mo></mrow></msub><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, we should specify</p>
<ul id="I2" class="ltx_itemize">
<li id="I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i1.p1" class="ltx_para">
<p class="ltx_p">An element <math id="I2.i1.p1.m1" class="ltx_Math" alttext="b:P(\mathsf{base})" display="inline"><mrow><mi>b</mi><mo>:</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math> in the fiber over the constructor <math id="I2.i1.p1.m2" class="ltx_Math" alttext="\mathsf{base}:\mathbb{S}^{1}" display="inline"><mrow><mi>𝖻𝖺𝗌𝖾</mi><mo>:</mo><msup><mi>𝕊</mi><mn>1</mn></msup></mrow></math>, and
</p>
</div>
</li>
<li id="I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i2.p1" class="ltx_para">
<p class="ltx_p">A path from <math id="I2.i2.p1.m1" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> to <math id="I2.i2.p1.m2" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> “lying over the constructor <math id="I2.i2.p1.m3" class="ltx_Math" alttext="\mathsf{loop}:\mathsf{base}=\mathsf{base}" display="inline"><mrow><mi>𝗅𝗈𝗈𝗉</mi><mo>:</mo><mrow><mi>𝖻𝖺𝗌𝖾</mi><mo>=</mo><mi>𝖻𝖺𝗌𝖾</mi></mrow></mrow></math>”.</p>
</div>
</li>
</ul>
<p class="ltx_p">Note that even though <math id="p7.m2" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math> contains paths other than <math id="p7.m3" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi>𝗅𝗈𝗈𝗉</mi></math> (such as <math id="p7.m4" class="ltx_Math" alttext="\mathsf{refl}_{\mathsf{base}}" display="inline"><msub><mi>𝗋𝖾𝖿𝗅</mi><mi>𝖻𝖺𝗌𝖾</mi></msub></math> and <math id="p7.m5" class="ltx_Math" alttext="\mathsf{loop}\mathchoice{\mathbin{\raisebox{2.15pt}{$\displaystyle\centerdot$}%
}}{\mathbin{\raisebox{2.15pt}{$\centerdot$}}}{\mathbin{\raisebox{1.075pt}{$%
\scriptstyle\,\centerdot\,$}}}{\mathbin{\raisebox{0.43pt}{$\scriptscriptstyle%
\,\centerdot\,$}}}\mathsf{loop}" display="inline"><mrow><mi>𝗅𝗈𝗈𝗉</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\centerdot</mtext></merror><mo>⁢</mo><mi>𝗅𝗈𝗈𝗉</mi></mrow></math>), we only need to specify a path lying over the constructor <em class="ltx_emph ltx_font_italic">itself</em>.
This expresses the intuition that <math id="p7.m6" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math> is “freely generated” by its constructors.</p>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">The question, however, is what it means to have a path “lying over” another path.
It definitely does <em class="ltx_emph ltx_font_italic">not</em> mean simply a path <math id="p8.m1" class="ltx_Math" alttext="b=b" display="inline"><mrow><mi>b</mi><mo>=</mo><mi>b</mi></mrow></math>, since that would be a path in the fiber <math id="p8.m2" class="ltx_Math" alttext="P(\mathsf{base})" display="inline"><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></math> (topologically, a path lying over the <em class="ltx_emph ltx_font_italic"><a class="nnexus_concept" href="http://planetmath.org/logicallanguage">constant</a></em> path at <math id="p8.m3" class="ltx_Math" alttext="\mathsf{base}" display="inline"><mi>𝖻𝖺𝗌𝖾</mi></math>).
Actually, however, we have already answered this question in <span class="ltx_text ltx_font_typewriter">http://planetmath.org/node/87569</span>Chapter 2: in the discussion preceding Lemma 2.3.4 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/23typefamiliesarefibrations#Thmprelem3</span>) we concluded that a path from <math id="p8.m4" class="ltx_Math" alttext="u:P(x)" display="inline"><mrow><mi>u</mi><mo>:</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math> to <math id="p8.m5" class="ltx_Math" alttext="v:P(y)" display="inline"><mrow><mi>v</mi><mo>:</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math> lying over <math id="p8.m6" class="ltx_Math" alttext="p:x=y" display="inline"><mrow><mi>p</mi><mo>:</mo><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></mrow></math> can be represented by a path <math id="p8.m7" class="ltx_Math" alttext="{p}_{*}\mathopen{}\left({u}\right)\mathclose{}=v" display="inline"><mrow><msub><mi>p</mi><mo>*</mo></msub><mrow><mi></mi><mrow><mo>(</mo><mi>u</mi><mo>)</mo></mrow><mi></mi></mrow><mo>=</mo><mi>v</mi></mrow></math> in the fiber <math id="p8.m8" class="ltx_Math" alttext="P(y)" display="inline"><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></math>.
Since we will have a lot of use for such <span class="ltx_text ltx_font_bold">dependent paths</span>
in this chapter, we introduce a special notation for them:
</p>
<table id="S0.E1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.E1.m1" class="ltx_Math" alttext="(u=^{P}_{p}v):\!\!\equiv(\mathsf{transport}^{P}(p,u)=v)." display="block"><mrow><mrow><mo stretchy="false">(</mo><mi>u</mi><msubsup><mo>=</mo><mi>p</mi><mi>P</mi></msubsup><mi>v</mi><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mrow><mo stretchy="false">(</mo><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mi>P</mi></msup><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(6.2.2)</span></td>
</tr>
</table>
</div>
<div id="Thmprermk2" class="ltx_theorem ltx_theorem_prermk">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Remark 6.2.3</span>.</h6>
<div id="Thmprermk2.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">There are other possible ways to define dependent paths.
For instance, instead of <math id="Thmprermk2.p1.m1" class="ltx_Math" alttext="{p}_{*}\mathopen{}\left({u}\right)\mathclose{}=v" display="inline"><mrow><msub><mi>p</mi><mo mathvariant="normal">*</mo></msub><mrow><mi></mi><mrow><mo mathvariant="normal">(</mo><mi>u</mi><mo mathvariant="normal">)</mo></mrow><mi></mi></mrow><mo mathvariant="normal">=</mo><mi>v</mi></mrow></math> we could consider <math id="Thmprermk2.p1.m2" class="ltx_Math" alttext="u={(\mathord{{p}^{-1}})}_{*}\mathopen{}\left({v}\right)\mathclose{}" display="inline"><mrow><mi>u</mi><mo mathvariant="normal">=</mo><msub><mrow><mo mathvariant="normal" stretchy="false">(</mo><msup><mi>p</mi><mrow><mo mathvariant="normal">-</mo><mn mathvariant="normal">1</mn></mrow></msup><mo mathvariant="normal" stretchy="false">)</mo></mrow><mo mathvariant="normal">*</mo></msub><mrow><mi></mi><mrow><mo mathvariant="normal">(</mo><mi>v</mi><mo mathvariant="normal">)</mo></mrow><mi></mi></mrow></mrow></math>.
We could also obtain it as a special case of a more general “heterogeneous equality”,
or with a direct definition as an inductive type family.
All these definitions result in equivalent types, so in that sense it doesn’t much matter which we pick.
However, choosing <math id="Thmprermk2.p1.m3" class="ltx_Math" alttext="{p}_{*}\mathopen{}\left({u}\right)\mathclose{}=v" display="inline"><mrow><msub><mi>p</mi><mo mathvariant="normal">*</mo></msub><mrow><mi></mi><mrow><mo mathvariant="normal">(</mo><mi>u</mi><mo mathvariant="normal">)</mo></mrow><mi></mi></mrow><mo mathvariant="normal">=</mo><mi>v</mi></mrow></math> as the definition makes it easiest to conclude other things about dependent paths, such as the fact that <math id="Thmprermk2.p1.m4" class="ltx_Math" alttext="\mathsf{apd}_{f}" display="inline"><msub><mi mathvariant="normal">apd</mi><mi>f</mi></msub></math> produces them, or that we can compute them in particular type families using the transport lemmas in §2.5 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/25thehighergroupoidstructureoftypeformers</span>).</span></p>
</div>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">With the notion of dependent paths in hand, we can now state more precisely the induction principle for <math id="p9.m1" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math>: given <math id="p9.m2" class="ltx_Math" alttext="P:\mathbb{S}^{1}\to\mathcal{U}" display="inline"><mrow><mi>P</mi><mo>:</mo><mrow><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></mrow></math> and</p>
<ul id="I3" class="ltx_itemize">
<li id="I3.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I3.i1.p1" class="ltx_para">
<p class="ltx_p">An element <math id="I3.i1.p1.m1" class="ltx_Math" alttext="b:P(\mathsf{base})" display="inline"><mrow><mi>b</mi><mo>:</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, and</p>
</div>
</li>
<li id="I3.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I3.i2.p1" class="ltx_para">
<p class="ltx_p">A path <math id="I3.i2.p1.m1" class="ltx_Math" alttext="\ell:b=^{P}_{\mathsf{loop}}b" display="inline"><mrow><mi mathvariant="normal">ℓ</mi><mo>:</mo><mrow><mi>b</mi><msubsup><mo>=</mo><mi>𝗅𝗈𝗈𝗉</mi><mi>P</mi></msubsup><mi>b</mi></mrow></mrow></math>,</p>
</div>
</li>
</ul>
<p class="ltx_p">there is a function <math id="p9.m3" class="ltx_Math" alttext="f:\mathchoice{\prod_{x:\mathbb{S}^{1}}\,}{\mathchoice{{\textstyle\prod_{(x:%
\mathbb{S}^{1})}}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{%
\prod_{(x:\mathbb{S}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S}^{1})}%
}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S%
}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S}^{1})}}}{\prod_{(x:%
\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}}P(x)" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo stretchy="false">)</mo></mrow></msub><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math> such that <math id="p9.m4" class="ltx_Math" alttext="f(\mathsf{base})\equiv b" display="inline"><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≡</mo><mi>b</mi></mrow></math> and <math id="p9.m5" class="ltx_Math" alttext="\mathsf{apd}_{f}\mathopen{}\left(\mathsf{loop}\right)\mathclose{}=\ell" display="inline"><mrow><msub><mi>𝖺𝗉𝖽</mi><mi>f</mi></msub><mrow><mi></mi><mrow><mo>(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>)</mo></mrow><mi></mi></mrow><mo>=</mo><mi mathvariant="normal">ℓ</mi></mrow></math>.
As in the non-dependent case, we speak of defining <math id="p9.m6" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> by <math id="p9.m7" class="ltx_Math" alttext="f(\mathsf{base}):\!\!\equiv b" display="inline"><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>b</mi></mrow></math> and <math id="p9.m8" class="ltx_Math" alttext="\mathsf{apd}_{f}\mathopen{}\left(\mathsf{loop}\right)\mathclose{}:=\ell" display="inline"><mrow><msub><mi>𝖺𝗉𝖽</mi><mi>f</mi></msub><mrow><mi></mi><mrow><mo>(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>)</mo></mrow><mi></mi></mrow><mo>:=</mo><mi mathvariant="normal">ℓ</mi></mrow></math>.</p>
</div>
<div id="Thmprermk3" class="ltx_theorem ltx_theorem_prermk">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Remark 6.2.4</span>.</h6>
<div id="Thmprermk3.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">When describing an application of this induction principle informally, we regard it as a splitting of the goal “<math id="Thmprermk3.p1.m1" class="ltx_Math" alttext="P(x)" display="inline"><mrow><mi>P</mi><mo mathvariant="italic">⁢</mo><mrow><mo mathvariant="normal" stretchy="false">(</mo><mi>x</mi><mo mathvariant="normal" stretchy="false">)</mo></mrow></mrow></math> for all <math id="Thmprermk3.p1.m2" class="ltx_Math" alttext="x:\mathbb{S}^{1}" display="inline"><mrow><mi>x</mi><mo mathvariant="normal">:</mo><msup><mi mathvariant="normal">S</mi><mn mathvariant="normal">1</mn></msup></mrow></math>” into two cases, which we will sometimes introduce with phrases such as “when <math id="Thmprermk3.p1.m3" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> is <math id="Thmprermk3.p1.m4" class="ltx_Math" alttext="\mathsf{base}" display="inline"><mi mathvariant="normal">base</mi></math>” and “when <math id="Thmprermk3.p1.m5" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> varies along <math id="Thmprermk3.p1.m6" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi mathvariant="normal">loop</mi></math>”, respectively.
There is no specific mathematical meaning assigned to “varying along a path”: it is just a convenient way to indicate the beginning of the corresponding <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">section</a><sup style="display: none;"><a class="nnexus_concept" href="http://planetmath.org/operationsonrelations"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/sheaf"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/sectionsandretractions"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/typesofmorphisms"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a><a class="nnexus_concept" href="http://planetmath.org/monic"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> of a proof; see Lemma 6.4.2 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/64circlesandspheres#Thmprelem2</span>) for an example.</span></p>
</div>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">Topologically, the induction principle for <math id="p10.m1" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math> can be visualized as shown in Figure 6.1 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/62inductionprinciplesanddependentpaths#S0.F1</span>).
Given a fibration over the circle (which in the picture is a torus), to define a section of this fibration is the same as to give a point <math id="p10.m2" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> in the fiber over <math id="p10.m3" class="ltx_Math" alttext="\mathsf{base}" display="inline"><mi>𝖻𝖺𝗌𝖾</mi></math> along with a path from <math id="p10.m4" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> to <math id="p10.m5" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> lying over <math id="p10.m6" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi>𝗅𝗈𝗈𝗉</mi></math>.
The way we interpret this type-theoretically, using our definition of dependent paths, is shown in Figure 6.2 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/62inductionprinciplesanddependentpaths#S0.F2</span>): the path from <math id="p10.m7" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> to <math id="p10.m8" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> over <math id="p10.m9" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi>𝗅𝗈𝗈𝗉</mi></math> is represented by a path from <math id="p10.m10" class="ltx_Math" alttext="{\mathsf{loop}}_{*}\mathopen{}\left({b}\right)\mathclose{}" display="inline"><mrow><msub><mi>𝗅𝗈𝗈𝗉</mi><mo>*</mo></msub><mrow><mi></mi><mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mi></mi></mrow></mrow></math> to <math id="p10.m11" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> in the fiber over <math id="p10.m12" class="ltx_Math" alttext="\mathsf{base}" display="inline"><mi>𝖻𝖺𝗌𝖾</mi></math>.</p>
</div>
<figure id="S0.F1" class="ltx_figure"><span class="ltx_ERROR ltx_centering undefined">\includegraphics</span>
<p class="ltx_p ltx_align_center">HoTT_fig_6.2.1.png</p>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6.1: </span>The topological induction principle for <math id="S0.F1.m2" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math></figcaption>
</figure>
<figure id="S0.F2" class="ltx_figure"><span class="ltx_ERROR ltx_centering undefined">\includegraphics</span>
<p class="ltx_p ltx_align_center">HoTT_fig_6.2.2.png</p>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6.2: </span>The type-theoretic induction principle for <math id="S0.F2.m2" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math></figcaption>
</figure>
<div id="p11" class="ltx_para">
<p class="ltx_p">Of course, we expect to be able to prove the recursion principle from the induction principle, by taking <math id="p11.m1" class="ltx_Math" alttext="P" display="inline"><mi>P</mi></math> to be a constant type family.
This is in fact the case, although deriving the non-dependent computation rule for <math id="p11.m2" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi>𝗅𝗈𝗈𝗉</mi></math> (which refers to <math id="p11.m3" class="ltx_Math" alttext="\mathsf{ap}_{f}" display="inline"><msub><mi>𝖺𝗉</mi><mi>f</mi></msub></math>) from the dependent one (which refers to <math id="p11.m4" class="ltx_Math" alttext="\mathsf{apd}_{f}" display="inline"><msub><mi>𝖺𝗉𝖽</mi><mi>f</mi></msub></math>) is surprisingly a little tricky.</p>
</div>
<div id="Thmprelem1" class="ltx_theorem ltx_theorem_prelem">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Lemma 6.2.5</span>.</h6>
<div id="Thmprelem1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">If <math id="Thmprelem1.p1.m1" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> is a type together with <math id="Thmprelem1.p1.m2" class="ltx_Math" alttext="a:A" display="inline"><mrow><mi>a</mi><mo mathvariant="normal">:</mo><mi>A</mi></mrow></math> and <math id="Thmprelem1.p1.m3" class="ltx_Math" alttext="p:a=_{A}a" display="inline"><mrow><mi>p</mi><mo mathvariant="normal">:</mo><mrow><mi>a</mi><msub><mo mathvariant="normal">=</mo><mi>A</mi></msub><mi>a</mi></mrow></mrow></math>, then there is a
function <math id="Thmprelem1.p1.m4" class="ltx_Math" alttext="f:\mathbb{S}^{1}\to{}A" display="inline"><mrow><mi>f</mi><mo mathvariant="normal">:</mo><mrow><msup><mi mathvariant="normal">S</mi><mn mathvariant="normal">1</mn></msup><mo mathvariant="normal">→</mo><mi>A</mi></mrow></mrow></math> with</span></p>
<table id="S0.EGx1" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tr id="S0.Ex1" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex1.m1" class="ltx_Math" alttext="\displaystyle f(\mathsf{base})" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex1.m2" class="ltx_Math" alttext="\displaystyle:\!\!\equiv a" display="inline"><mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>a</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr id="S0.Ex2" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex2.m1" class="ltx_Math" alttext="\displaystyle\mathsf{ap}_{f}(\mathsf{loop})" display="inline"><mrow><msub><mi>𝖺𝗉</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex2.m2" class="ltx_Math" alttext="\displaystyle:=p." display="inline"><mrow><mrow><mi></mi><mo>:=</mo><mi>p</mi></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</div>
<div class="ltx_proof">
<h6 class="ltx_title ltx_runin ltx_font_italic ltx_title_proof">Proof.</h6>
<div id="p12" class="ltx_para">
<p class="ltx_p">We would like to apply the induction principle of <math id="p12.m1" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math> to the constant type family, <math id="p12.m2" class="ltx_Math" alttext="({\lambda}x.\,A):\mathbb{S}^{1}\to\mathcal{U}" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo rspace="4.2pt">.</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></math>.
The required hypotheses for this are a point of <math id="p12.m3" class="ltx_Math" alttext="({\lambda}x.\,A)(\mathsf{base})\equiv A" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo rspace="4.2pt">.</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow><mo>≡</mo><mi>A</mi></mrow></math>, which we have (namely <math id="p12.m4" class="ltx_Math" alttext="a:A" display="inline"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math>), and a dependent path in <math id="p12.m5" class="ltx_Math" alttext="a=^{x\mapsto A}_{\mathsf{loop}}a" display="inline"><mrow><mi>a</mi><msubsup><mo>=</mo><mi>𝗅𝗈𝗈𝗉</mi><mrow><mi>x</mi><mo>↦</mo><mi>A</mi></mrow></msubsup><mi>a</mi></mrow></math>, or equivalently <math id="p12.m6" class="ltx_Math" alttext="\mathsf{transport}^{x\mapsto A}(\mathsf{loop},a)=a" display="inline"><mrow><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mrow><mi>x</mi><mo>↦</mo><mi>A</mi></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>a</mi></mrow></math>.
This latter type is not the same as the type <math id="p12.m7" class="ltx_Math" alttext="a=_{A}a" display="inline"><mrow><mi>a</mi><msub><mo>=</mo><mi>A</mi></msub><mi>a</mi></mrow></math> where <math id="p12.m8" class="ltx_Math" alttext="p" display="inline"><mi>p</mi></math> lives, but it is equivalent to it, because by Lemma 2.3.5 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/23typefamiliesarefibrations#Thmprelem4</span>) we have <math id="p12.m9" class="ltx_Math" alttext="\mathsf{transportconst}^{A}_{\mathsf{loop}}(a):\mathsf{transport}^{x\mapsto A}%
(\mathsf{loop},a)=a" display="inline"><mrow><mrow><msubsup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍𝖼𝗈𝗇𝗌𝗍</mi><mi>𝗅𝗈𝗈𝗉</mi><mi>A</mi></msubsup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mrow><mi>x</mi><mo>↦</mo><mi>A</mi></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>a</mi></mrow></mrow></math>.
Thus, given <math id="p12.m10" class="ltx_Math" alttext="a:A" display="inline"><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></math> and <math id="p12.m11" class="ltx_Math" alttext="p:a=a" display="inline"><mrow><mi>p</mi><mo>:</mo><mrow><mi>a</mi><mo>=</mo><mi>a</mi></mrow></mrow></math>, we can consider the composite</p>
<table id="S0.Ex3" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex3.m1" class="ltx_Math" alttext="\mathsf{transportconst}^{A}_{\mathsf{loop}}(a)\mathchoice{\mathbin{\raisebox{2%
.15pt}{$\displaystyle\centerdot$}}}{\mathbin{\raisebox{2.15pt}{$\centerdot$}}}%
{\mathbin{\raisebox{1.075pt}{$\scriptstyle\,\centerdot\,$}}}{\mathbin{%
\raisebox{0.43pt}{$\scriptscriptstyle\,\centerdot\,$}}}p:(a=^{x\mapsto A}_{%
\mathsf{loop}}a)." display="block"><mrow><msubsup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍𝖼𝗈𝗇𝗌𝗍</mi><mi>𝗅𝗈𝗈𝗉</mi><mi>A</mi></msubsup><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><merror class="ltx_ERROR undefined undefined"><mtext>\centerdot</mtext></merror><mi>p</mi><mo>:</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><msubsup><mo>=</mo><mi>𝗅𝗈𝗈𝗉</mi><mrow><mi>x</mi><mo>↦</mo><mi>A</mi></mrow></msubsup><mi>a</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Applying the induction principle, we obtain <math id="p12.m12" class="ltx_Math" alttext="f:\mathbb{S}^{1}\to A" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi>A</mi></mrow></mrow></math> such that</p>
<table id="S0.EGx2" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tbody id="S0.E2"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.E2.m1" class="ltx_Math" alttext="\displaystyle f(\mathsf{base})" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.E2.m2" class="ltx_Math" alttext="\displaystyle\equiv a\qquad\text{and}" display="inline"><mrow><mi></mi><mo>≡</mo><mrow><mi>a</mi><mo mathvariant="italic" separator="true">  </mo><mtext>and</mtext></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(6.2.6)</span></td>
</tr></tbody>
<tbody id="S0.E3"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.E3.m1" class="ltx_Math" alttext="\displaystyle\mathsf{apd}_{f}(\mathsf{loop})" display="inline"><mrow><msub><mi>𝖺𝗉𝖽</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.E3.m2" class="ltx_Math" alttext="\displaystyle=\mathsf{transportconst}^{A}_{\mathsf{loop}}(a)\mathchoice{%
\mathbin{\raisebox{2.15pt}{$\displaystyle\centerdot$}}}{\mathbin{\raisebox{2.1%
5pt}{$\centerdot$}}}{\mathbin{\raisebox{1.075pt}{$\scriptstyle\,\centerdot\,$}%
}}{\mathbin{\raisebox{0.43pt}{$\scriptscriptstyle\,\centerdot\,$}}}p." display="inline"><mrow><mrow><mi></mi><mo>=</mo><mrow><msubsup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍𝖼𝗈𝗇𝗌𝗍</mi><mi>𝗅𝗈𝗈𝗉</mi><mi>A</mi></msubsup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\centerdot</mtext></merror><mo>⁢</mo><mi>p</mi></mrow></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(6.2.6)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">It remains to derive the equality <math id="p12.m13" class="ltx_Math" alttext="\mathsf{ap}_{f}(\mathsf{loop})=p" display="inline"><mrow><mrow><msub><mi>𝖺𝗉</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>p</mi></mrow></math>.
However, by Lemma 2.3.8 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/23typefamiliesarefibrations#Thmprelem5</span>), we have</p>
<table id="S0.Ex4" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex4.m1" class="ltx_Math" alttext="\mathsf{apd}_{f}(\mathsf{loop})=\mathsf{transportconst}^{A}_{\mathsf{loop}}(f(%
\mathsf{base}))\mathchoice{\mathbin{\raisebox{2.15pt}{$\displaystyle\centerdot%
$}}}{\mathbin{\raisebox{2.15pt}{$\centerdot$}}}{\mathbin{\raisebox{1.075pt}{$%
\scriptstyle\,\centerdot\,$}}}{\mathbin{\raisebox{0.43pt}{$\scriptscriptstyle%
\,\centerdot\,$}}}\mathsf{ap}_{f}(\mathsf{loop})." display="block"><mrow><mrow><mrow><msub><mi>𝖺𝗉𝖽</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍𝖼𝗈𝗇𝗌𝗍</mi><mi>𝗅𝗈𝗈𝗉</mi><mi>A</mi></msubsup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\centerdot</mtext></merror><mo>⁢</mo><msub><mi>𝖺𝗉</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Combining this with (<a href="#S0.E3" title="(6.2.6) ‣ 6.2 Induction principles and dependent paths" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.2.6</span></a>) and canceling the <a class="nnexus_concept" href="http://planetmath.org/word">occurrences</a> of <math id="p12.m14" class="ltx_Math" alttext="\mathsf{transportconst}" display="inline"><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍𝖼𝗈𝗇𝗌𝗍</mi></math> (which are the same by (<a href="#S0.E2" title="(6.2.6) ‣ 6.2 Induction principles and dependent paths" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.2.6</span></a>)), we obtain <math id="p12.m15" class="ltx_Math" alttext="\mathsf{ap}_{f}(\mathsf{loop})=p" display="inline"><mrow><mrow><msub><mi>𝖺𝗉</mi><mi>f</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>p</mi></mrow></math>.
∎</p>
</div>
</div>
<div id="p13" class="ltx_para">
<p class="ltx_p">We also have a corresponding uniqueness principle.</p>
</div>
<div id="Thmprelem2" class="ltx_theorem ltx_theorem_prelem">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Lemma 6.2.6</span>.</h6>
<div id="Thmprelem2.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">If <math id="Thmprelem2.p1.m1" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> is a type and <math id="Thmprelem2.p1.m2" class="ltx_Math" alttext="f,g:\mathbb{S}^{1}\to{}A" display="inline"><mrow><mrow><mi>f</mi><mo mathvariant="normal">,</mo><mi>g</mi></mrow><mo mathvariant="normal">:</mo><mrow><msup><mi mathvariant="normal">S</mi><mn mathvariant="normal">1</mn></msup><mo mathvariant="normal">→</mo><mi>A</mi></mrow></mrow></math> are two maps together with two
equalities <math id="Thmprelem2.p1.m3" class="ltx_Math" alttext="p,q" display="inline"><mrow><mi>p</mi><mo mathvariant="normal">,</mo><mi>q</mi></mrow></math>:</span></p>
<table id="S0.EGx3" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tr id="S0.Ex5" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex5.m1" class="ltx_Math" alttext="\displaystyle p:f(\mathsf{base})" display="inline"><mrow><mi>p</mi><mo>:</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex5.m2" class="ltx_Math" alttext="\displaystyle=_{A}g(\mathsf{base})," display="inline"><mrow><mrow><mi></mi><msub><mo>=</mo><mi>A</mi></msub><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr id="S0.Ex6" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex6.m1" class="ltx_Math" alttext="\displaystyle q:{f}\mathopen{}\left({\mathsf{loop}}\right)\mathclose{}" display="inline"><mrow><mi>q</mi><mo>:</mo><mi>f</mi><mrow><mi></mi><mrow><mo>(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>)</mo></mrow><mi></mi></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex6.m2" class="ltx_Math" alttext="\displaystyle=^{{\lambda}x.\,x=_{A}x}_{p}{g}\mathopen{}\left({\mathsf{loop}}%
\right)\mathclose{}." display="inline"><mrow><msubsup><mo>=</mo><mi>p</mi><mrow><mrow><mi>λ</mi><mo>⁢</mo><mi>x</mi></mrow><mo rspace="4.2pt">.</mo><mrow><mi>x</mi><msub><mo>=</mo><mi>A</mi></msub><mi>x</mi></mrow></mrow></msubsup><mi>g</mi><mrow><mi></mi><mrow><mo>(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>)</mo></mrow><mi></mi></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p"><span class="ltx_text ltx_font_italic">Then for all <math id="Thmprelem2.p1.m4" class="ltx_Math" alttext="x:\mathbb{S}^{1}" display="inline"><mrow><mi>x</mi><mo mathvariant="normal">:</mo><msup><mi mathvariant="normal">S</mi><mn mathvariant="normal">1</mn></msup></mrow></math> we have <math id="Thmprelem2.p1.m5" class="ltx_Math" alttext="f(x)=g(x)" display="inline"><mrow><mrow><mi>f</mi><mo mathvariant="italic">⁢</mo><mrow><mo mathvariant="normal" stretchy="false">(</mo><mi>x</mi><mo mathvariant="normal" stretchy="false">)</mo></mrow></mrow><mo mathvariant="normal">=</mo><mrow><mi>g</mi><mo mathvariant="italic">⁢</mo><mrow><mo mathvariant="normal" stretchy="false">(</mo><mi>x</mi><mo mathvariant="normal" stretchy="false">)</mo></mrow></mrow></mrow></math>.</span></p>
</div>
</div>
<div class="ltx_proof">
<h6 class="ltx_title ltx_runin ltx_font_italic ltx_title_proof">Proof.</h6>
<div id="p14" class="ltx_para">
<p class="ltx_p">This is just the induction principle for the type family <math id="p14.m1" class="ltx_Math" alttext="P(x):\!\!\equiv(f(x)=g(x))" display="inline"><mrow><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.
∎</p>
</div>
</div>
<div id="p15" class="ltx_para">
<p class="ltx_p">These two lemmas imply the expected <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">universal property</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/UniversalProperty.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/universalmappingproperty"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> of the circle:</p>
</div>
<div id="Thmprelem3" class="ltx_theorem ltx_theorem_prelem">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Lemma 6.2.7</span>.</h6>
<div id="Thmprelem3.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">For any type <math id="Thmprelem3.p1.m1" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> we have a <a class="nnexus_concept" href="http://planetmath.org/naturalequivalence">natural equivalence</a></span></p>
<table id="S0.Ex7" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex7.m1" class="ltx_Math" alttext="(\mathbb{S}^{1}\to A)\;\simeq\;\mathchoice{\sum_{x:A}\,}{\mathchoice{{%
\textstyle\sum_{(x:A)}}}{\sum_{(x:A)}}{\sum_{(x:A)}}{\sum_{(x:A)}}}{%
\mathchoice{{\textstyle\sum_{(x:A)}}}{\sum_{(x:A)}}{\sum_{(x:A)}}{\sum_{(x:A)}%
}}{\mathchoice{{\textstyle\sum_{(x:A)}}}{\sum_{(x:A)}}{\sum_{(x:A)}}{\sum_{(x:%
A)}}}(x=x)." display="block"><mrow><mrow><mo stretchy="false">(</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi>A</mi><mo rspace="5.3pt" stretchy="false">)</mo></mrow><mo rspace="5.3pt">≃</mo><mpadded width="+1.7pt"><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></munder></mpadded><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</div>
<div class="ltx_proof">
<h6 class="ltx_title ltx_runin ltx_font_italic ltx_title_proof">Proof.</h6>
<div id="p16" class="ltx_para">
<p class="ltx_p">We have a canonical function <math id="p16.m1" class="ltx_Math" alttext="f:(\mathbb{S}^{1}\to A)\to\mathchoice{\sum_{x:A}\,}{\mathchoice{{\textstyle%
\sum_{(x:A)}}}{\sum_{(x:A)}}{\sum_{(x:A)}}{\sum_{(x:A)}}}{\mathchoice{{%
\textstyle\sum_{(x:A)}}}{\sum_{(x:A)}}{\sum_{(x:A)}}{\sum_{(x:A)}}}{%
\mathchoice{{\textstyle\sum_{(x:A)}}}{\sum_{(x:A)}}{\sum_{(x:A)}}{\sum_{(x:A)}%
}}(x=x)" display="inline"><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="false">(</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mo>→</mo><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> defined by <math id="p16.m2" class="ltx_Math" alttext="f(g):\!\!\equiv(g(\mathsf{base}),{g}\mathopen{}\left({\mathsf{loop}}\right)%
\mathclose{})" display="inline"><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><mo rspace="0pt">:</mo><mo>≡</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow><mo>,</mo><mi>g</mi><mrow><mi></mi><mrow><mo>(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>)</mo></mrow><mi></mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.
The induction principle shows that the fibers of <math id="p16.m3" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> are inhabited, while the uniqueness principle shows that they are mere propositions.
Hence they are <a class="nnexus_concept" href="http://mathworld.wolfram.com/Contractible.html">contractible</a>, so <math id="p16.m4" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> is an equivalence.
∎</p>
</div>
</div>
<div id="p17" class="ltx_para">
<p class="ltx_p">As in §5.5 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/55homotopyinductivetypes</span>), we can show that the <a class="nnexus_concepts" href="javascript:void(0)" onclick="this.nextSibling.style.display='inline'">conclusion</a><sup style="display: none;"><a class="nnexus_concept" href="http://mathworld.wolfram.com/Conclusion.html"><img src="http://mathworld.wolfram.com/favicon_mathworld.png" alt="Mathworld"></img></a><a class="nnexus_concept" href="http://planetmath.org/sequent"><img src="http://planetmath.org/sites/default/files/fab-favicon.ico" alt="Planetmath"></img></a></sup> of Lemma 6.2.7 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/62inductionprinciplesanddependentpaths#Thmprelem3</span>) is equivalent to having an induction principle with propositional computation rules.
Other higher inductive types also <a class="nnexus_concept" href="http://planetmath.org/satisfactionrelation">satisfy</a> lemmas analogous to Lemma 6.2.5 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/62inductionprinciplesanddependentpaths#Thmprelem1</span>),Lemma 6.2.7 (<span class="ltx_text ltx_font_typewriter">http://planetmath.org/62inductionprinciplesanddependentpaths#Thmprelem3</span>); we will generally leave their proofs to the reader.
We now proceed to consider many examples.</p>
</div>
<div id="p18" class="ltx_para ltx_align_right">
<table class="ltx_tabular ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_l ltx_border_t">Title</td>
<td class="ltx_td ltx_align_left ltx_border_r ltx_border_t">6.2 Induction principles and dependent paths</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_l ltx_border_t"><span class="ltx_ERROR undefined">\metatable</span></td>
<td class="ltx_td ltx_border_t"></td>
</tr>
</tbody>
</table>
</div>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Feb  8 19:37:58 2018 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
