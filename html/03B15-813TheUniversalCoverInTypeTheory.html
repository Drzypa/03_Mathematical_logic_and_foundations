<!DOCTYPE html><html>
<head>
<title>8.1.3 The universal cover in type theory</title>
<!--Generated on Thu Feb  8 19:40:23 2018 by LaTeXML (version 0.8.2) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/3f71ceeb3b055e1ddc3b6c11fb1f074c/raw/2bb23e3b173ff96840797fc0c3bcb8c54085df8e/LaTeXML.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/4bda0365b30858ac2fb83623185fe3ec/raw/cedd84ed3e3ad597c5d293f443ecfe4803741c6b/ltx-article.css" type="text/css">
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML" type="text/javascript"></script>
<meta name="keywords" lang="en" content="cover, covering space, integers, isomorphism on , predecessor, successor, universal">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">8.1.3 The universal cover in type theory</h1>

<div id="p1" class="ltx_para">
<br class="ltx_break">
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">Let us consider how we might express the preceding proof in type theory.
We have already remarked that the path fibration of <math id="p2.m1" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math> is represented by the type family <math id="p2.m2" class="ltx_Math" alttext="(x\mapsto(\mathsf{base}=x))" display="inline"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>↦</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></math>.
We have also already seen a good candidate for the universal cover of <math id="p2.m3" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math>: it’s none other than the type family <math id="p2.m4" class="ltx_Math" alttext="c:\mathbb{S}^{1}\to\mathcal{U}" display="inline"><mrow><mi>c</mi><mo>:</mo><mrow><msup><mi>𝕊</mi><mn>1</mn></msup><mo>→</mo><mi class="ltx_font_mathcaligraphic">𝒰</mi></mrow></mrow></math> which we defined in <span class="ltx_ERROR undefined">\autoref</span>sec:pi1s1-initial-thoughts!
By definition, the fiber of this family over <math id="p2.m5" class="ltx_Math" alttext="\mathsf{base}" display="inline"><mi>𝖻𝖺𝗌𝖾</mi></math> is <math id="p2.m6" class="ltx_Math" alttext="\mathbb{Z}" display="inline"><mi>ℤ</mi></math>, while the effect of transporting around <math id="p2.m7" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi>𝗅𝗈𝗈𝗉</mi></math> is to add one — thus it behaves just as we would expect from <span class="ltx_ERROR undefined">\autoref</span>fig:winding.</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">However, since we don’t know yet that this family behaves like a universal cover is supposed to (for instance, that its total space is simply connected), we use a different name for it.
For reference, therefore, we repeat the definition.

</p>
</div>
<div id="Thmpredefn1" class="ltx_theorem ltx_theorem_predefn">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Definition 8.1.1</span> (Universal Cover of <math id="Thmpredefn1.m1" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi mathvariant="normal">S</mi><mn mathvariant="normal">1</mn></msup></math>).</h6>
<div id="Thmpredefn1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">Define <math id="Thmpredefn1.p1.m1" class="ltx_Math" alttext="\mathsf{code}:\mathbb{S}^{1}\to\mathcal{U}" display="inline"><mrow><mi mathvariant="normal">code</mi><mo mathvariant="normal">:</mo><mrow><msup><mi mathvariant="normal">S</mi><mn mathvariant="normal">1</mn></msup><mo mathvariant="normal">→</mo><mi class="ltx_font_mathcaligraphic" mathvariant="normal">U</mi></mrow></mrow></math> by circle-recursion, with</span></p>
<table id="S0.EGx1" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tr id="S0.Ex1" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex1.m1" class="ltx_Math" alttext="\displaystyle\mathsf{code}(\mathsf{base})" display="inline"><mrow><mi>𝖼𝗈𝖽𝖾</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex1.m2" class="ltx_Math" alttext="\displaystyle:\!\!\equiv\mathbb{Z}" display="inline"><mrow><mo rspace="0pt">:</mo><mo>≡</mo><mi>ℤ</mi></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr id="S0.Ex2" class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex2.m1" class="ltx_Math" alttext="\displaystyle\mathsf{ap}_{\mathsf{code}}({\mathsf{loop}})" display="inline"><mrow><msub><mi>𝖺𝗉</mi><mi>𝖼𝗈𝖽𝖾</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex2.m2" class="ltx_Math" alttext="\displaystyle:=\mathsf{ua}(\mathsf{succ})." display="inline"><mrow><mrow><mi></mi><mo>:=</mo><mrow><mi>𝗎𝖺</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗌𝗎𝖼𝖼</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">We emphasize briefly the definition of this family, since it is so different from how one usually defines covering spaces in classical homotopy theory.
To define a function by circle recursion, we need to find a point and a
loop in the codomain. In this case, the codomain is <math id="p4.m1" class="ltx_Math" alttext="\mathcal{U}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒰</mi></math>, and the point
we choose is <math id="p4.m2" class="ltx_Math" alttext="\mathbb{Z}" display="inline"><mi>ℤ</mi></math>, corresponding to our expectation that the
fiber of the universal cover should be the integers. The loop we choose
is the successor/predecessor
isomorphism on <math id="p4.m5" class="ltx_Math" alttext="\mathbb{Z}" display="inline"><mi>ℤ</mi></math>, which
corresponds to the fact that going around the loop in the base goes up
one level on the helix. Univalence is necessary for this part of the
proof, because we need to convert a <em class="ltx_emph ltx_font_italic">non-trivial</em> equivalence on <math id="p4.m6" class="ltx_Math" alttext="\mathbb{Z}" display="inline"><mi>ℤ</mi></math> into an identity.</p>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">We call this the fibration of “codes”, because its elements are combinatorial data that act as codes for paths on the circle: the integer <math id="p5.m1" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> codes for the path which loops around the circle <math id="p5.m2" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> times.</p>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">From this definition, it is simple to calculate that transporting with
<math id="p6.m1" class="ltx_Math" alttext="\mathsf{code}" display="inline"><mi>𝖼𝗈𝖽𝖾</mi></math> takes <math id="p6.m2" class="ltx_Math" alttext="\mathsf{loop}" display="inline"><mi>𝗅𝗈𝗈𝗉</mi></math> to the successor function, and
<math id="p6.m3" class="ltx_Math" alttext="\mathord{{\mathsf{loop}}^{-1}}" display="inline"><msup><mi>𝗅𝗈𝗈𝗉</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup></math> to the predecessor function:</p>
</div>
<div id="Thmprelem1" class="ltx_theorem ltx_theorem_prelem">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Lemma 8.1.2</span>.</h6>
<div id="Thmprelem1.p1" class="ltx_para">
<p class="ltx_p"><math id="Thmprelem1.p1.m1" class="ltx_Math" alttext="\mathsf{transport}^{\mathsf{code}}(\mathsf{loop},x)=x+1" display="inline"><mrow><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mi>𝖼𝗈𝖽𝖾</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></mrow></math><span class="ltx_text ltx_font_italic"> and
<math id="Thmprelem1.p1.m2" class="ltx_Math" alttext="\mathsf{transport}^{\mathsf{code}}(\mathord{{\mathsf{loop}}^{-1}},x)=x-1" display="inline"><mrow><mrow><msup><mi mathvariant="normal">transport</mi><mi mathvariant="normal">code</mi></msup><mo mathvariant="italic">⁢</mo><mrow><mo mathvariant="normal" stretchy="false">(</mo><msup><mi mathvariant="normal">loop</mi><mrow><mo mathvariant="normal">-</mo><mn mathvariant="normal">1</mn></mrow></msup><mo mathvariant="normal">,</mo><mi>x</mi><mo mathvariant="normal" stretchy="false">)</mo></mrow></mrow><mo mathvariant="normal">=</mo><mrow><mi>x</mi><mo mathvariant="normal">-</mo><mn mathvariant="normal">1</mn></mrow></mrow></math>.</span></p>
</div>
</div>
<div class="ltx_proof">
<h6 class="ltx_title ltx_runin ltx_font_italic ltx_title_proof">Proof.</h6>
<div id="p7" class="ltx_para">
<p class="ltx_p">For the first equation, we calculate as follows:</p>
<table id="S0.EGx2" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tbody id="S0.Ex3"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.Ex3.m1" class="ltx_Math" alttext="\displaystyle{\mathsf{transport}^{\mathsf{code}}(\mathsf{loop},x)}" display="inline"><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mi>𝖼𝗈𝖽𝖾</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex3.m2" class="ltx_Math" alttext="\displaystyle=\mathsf{transport}^{A\mapsto A}(({\mathsf{code}}\mathopen{}\left%
({\mathsf{loop}}\right)\mathclose{}),x){}" display="inline"><mrow><mo>=</mo><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mrow><mi>A</mi><mo>↦</mo><mi>A</mi></mrow></msup><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>𝖼𝗈𝖽𝖾</mi><mrow><mi></mi><mrow><mo>(</mo><mi>𝗅𝗈𝗈𝗉</mi><mo>)</mo></mrow><mi></mi></mrow><mo stretchy="false">)</mo></mrow><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(by \autorefthm:transport-compose)</span></td>
</tr></tbody>
<tbody id="S0.Ex4"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex4.m2" class="ltx_Math" alttext="\displaystyle=\mathsf{transport}^{A\mapsto A}(\mathsf{ua}(\mathsf{succ}),x){}" display="inline"><mrow><mi></mi><mo>=</mo><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mrow><mi>A</mi><mo>↦</mo><mi>A</mi></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>𝗎𝖺</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝗌𝗎𝖼𝖼</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(by computation for $\mathsf{rec}_{\mathbb{S}^{1}}$)</span></td>
</tr></tbody>
<tbody id="S0.Ex5"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.Ex5.m2" class="ltx_Math" alttext="\displaystyle=x+1{}." display="inline"><mrow><mrow><mi></mi><mo>=</mo><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(by computation for $\mathsf{ua}$)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">The second equation follows from the first, because <math id="p7.m1" class="ltx_Math" alttext="\mathsf{transport}^{B}(p,\mathord{\hskip 1.0pt\text{--}\hskip 1.0pt})" display="inline"><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mi>B</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mpadded lspace="1pt" width="+2pt"><mtext>–</mtext></mpadded><mo stretchy="false">)</mo></mrow></mrow></math> and <math id="p7.m2" class="ltx_Math" alttext="\mathsf{transport}^{B}(\mathord{{p}^{-1}},\mathord{\hskip 1.0pt\text{--}\hskip
1%
.0pt})" display="inline"><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mi>B</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>p</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>,</mo><mpadded lspace="1pt" width="+2pt"><mtext>–</mtext></mpadded><mo stretchy="false">)</mo></mrow></mrow></math> are always inverses, so <math id="p7.m3" class="ltx_Math" alttext="\mathsf{transport}^{\mathsf{code}}(\mathord{{\mathsf{loop}}^{-1}},\mathord{%
\hskip 1.0pt\text{--}\hskip 1.0pt})" display="inline"><mrow><msup><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi><mi>𝖼𝗈𝖽𝖾</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>𝗅𝗈𝗈𝗉</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>,</mo><mpadded lspace="1pt" width="+2pt"><mtext>–</mtext></mpadded><mo stretchy="false">)</mo></mrow></mrow></math> must be the inverse of <math id="p7.m4" class="ltx_Math" alttext="\mathsf{succ}" display="inline"><mi>𝗌𝗎𝖼𝖼</mi></math>.
∎</p>
</div>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">We can now see what was wrong with our first approach: we defined <math id="p8.m1" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> and <math id="p8.m2" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> only on the fibers <math id="p8.m3" class="ltx_Math" alttext="\Omega(\mathbb{S}^{1})" display="inline"><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo stretchy="false">)</mo></mrow></mrow></math> and <math id="p8.m4" class="ltx_Math" alttext="\mathbb{Z}" display="inline"><mi>ℤ</mi></math>, when we should have defined a whole morphism <em class="ltx_emph ltx_font_italic">of fibrations</em> over <math id="p8.m5" class="ltx_Math" alttext="\mathbb{S}^{1}" display="inline"><msup><mi>𝕊</mi><mn>1</mn></msup></math>.
In type theory, this means we should have defined functions having types</p>
<table id="S0.EGx3" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tbody id="S0.E1"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.E1.m1" class="ltx_Math" alttext="\displaystyle\mathchoice{\prod_{x:\mathbb{S}^{1}}\,}{\mathchoice{{\textstyle%
\prod_{(x:\mathbb{S}^{1})}}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^%
{1})}}{\prod_{(x:\mathbb{S}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S%
}^{1})}}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:%
\mathbb{S}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S}^{1})}}}{\prod_{%
(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}}" display="inline"><mpadded width="+1.7pt"><mstyle displaystyle="true"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>x</mi><mo>:</mo><msup><mi>𝕊</mi><mn>1</mn></msup></mrow></munder></mstyle></mpadded></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.E1.m2" class="ltx_Math" alttext="\displaystyle((\mathsf{base}=x)\to\mathsf{code}(x))\qquad\text{and/or}" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>→</mo><mi>𝖼𝗈𝖽𝖾</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo mathvariant="italic" separator="true">  </mo><mtext>and/or</mtext></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(1)</span></td>
</tr></tbody>
<tbody id="S0.E2"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S0.E2.m1" class="ltx_Math" alttext="\displaystyle\mathchoice{\prod_{x:\mathbb{S}^{1}}\,}{\mathchoice{{\textstyle%
\prod_{(x:\mathbb{S}^{1})}}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^%
{1})}}{\prod_{(x:\mathbb{S}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S%
}^{1})}}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:%
\mathbb{S}^{1})}}}{\mathchoice{{\textstyle\prod_{(x:\mathbb{S}^{1})}}}{\prod_{%
(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}{\prod_{(x:\mathbb{S}^{1})}}}" display="inline"><mpadded width="+1.7pt"><mstyle displaystyle="true"><munder><mo largeop="true" movablelimits="false" symmetric="true">∏</mo><mrow><mi>x</mi><mo>:</mo><msup><mi>𝕊</mi><mn>1</mn></msup></mrow></munder></mstyle></mpadded></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S0.E2.m2" class="ltx_Math" alttext="\displaystyle(\mathsf{code}(x)\to(\mathsf{base}=x))" display="inline"><mrow><mo stretchy="false">(</mo><mi>𝖼𝗈𝖽𝖾</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>→</mo><mrow><mo stretchy="false">(</mo><mi>𝖻𝖺𝗌𝖾</mi><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right"><span class="ltx_tag ltx_tag_equation ltx_align_right">(2)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">instead of only the special cases of these when <math id="p8.m6" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> is <math id="p8.m7" class="ltx_Math" alttext="\mathsf{base}" display="inline"><mi>𝖻𝖺𝗌𝖾</mi></math>.
This is also an instance of a common observation in type theory: when attempting to prove something about particular inhabitants of some inductive type, it is often easier to generalize the statement so that it refers to <em class="ltx_emph ltx_font_italic">all</em> inhabitants of that type, which we can then prove by induction.
Looked at in this way, the proof of <math id="p8.m8" class="ltx_Math" alttext="\Omega(\mathbb{S}^{1})=\mathbb{Z}" display="inline"><mrow><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>ℤ</mi></mrow></math> fits into the same pattern as the characterization of the identity types of coproducts and natural numbers in <span class="ltx_ERROR undefined">\autoref</span>sec:compute-coprod,<span class="ltx_ERROR undefined">\autoref</span>sec:compute-nat.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">At this point, there are two ways to finish the proof.
We can continue mimicking the classical argument by constructing (<a href="#S0.E1" title="(1) ‣ 8.1.3 The universal cover in type theory" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>) or (<a href="#S0.E2" title="(2) ‣ 8.1.3 The universal cover in type theory" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>) (it doesn’t matter which), proving that a homotopy equivalence between total spaces induces an equivalence on fibers, and then that the total space of the universal cover is contractible.
The first type-theoretic proof of <math id="p9.m1" class="ltx_Math" alttext="\Omega(\mathbb{S}^{1})=\mathbb{Z}" display="inline"><mrow><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>𝕊</mi><mn>1</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>ℤ</mi></mrow></math> followed this pattern; we call it the <em class="ltx_emph ltx_font_italic">homotopy-theoretic</em> proof.</p>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">Later, however, we discovered that there is an alternative proof, which has a more type-theoretic feel and more closely follows the proofs in <span class="ltx_ERROR undefined">\autoref</span>sec:compute-coprod,<span class="ltx_ERROR undefined">\autoref</span>sec:compute-nat.
In this proof, we directly construct both (<a href="#S0.E1" title="(1) ‣ 8.1.3 The universal cover in type theory" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>) and (<a href="#S0.E2" title="(2) ‣ 8.1.3 The universal cover in type theory" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>), and prove that they are mutually inverse by calculation.
We will call this the <em class="ltx_emph ltx_font_italic">encode-decode</em> proof, because we call the functions (<a href="#S0.E1" title="(1) ‣ 8.1.3 The universal cover in type theory" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>) and (<a href="#S0.E2" title="(2) ‣ 8.1.3 The universal cover in type theory" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>) <em class="ltx_emph ltx_font_italic">encode</em> and <em class="ltx_emph ltx_font_italic">decode</em> respectively.
Both proofs use the same construction of the cover given above.
Where the classical proof induces an equivalence on fibers from an equivalence between total spaces, the encode-decode proof constructs the inverse map (<em class="ltx_emph ltx_font_italic">decode</em>) explicitly as a map between fibers.
And where the classical proof uses contractibility, the encode-decode proof uses path induction, circle induction, and integer induction.
These are the same tools used to prove contractibility—indeed, path induction <em class="ltx_emph ltx_font_italic">is</em> essentially contractibility of the path fibration composed with <math id="p10.m1" class="ltx_Math" alttext="\mathsf{transport}" display="inline"><mi>𝗍𝗋𝖺𝗇𝗌𝗉𝗈𝗋𝗍</mi></math>—but they are applied in a different way.</p>
</div>
<div id="p11" class="ltx_para">
<p class="ltx_p">Since this is a book about homotopy type theory, we present the encode-decode proof first.
A homotopy theorist who gets lost is encouraged to skip to the homotopy-theoretic proof (<span class="ltx_ERROR undefined">\autoref</span>subsec:pi1s1-homotopy-theory).</p>
</div>
<div id="p12" class="ltx_para ltx_align_right">
<table class="ltx_tabular ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_l ltx_border_t">Title</td>
<td class="ltx_td ltx_align_left ltx_border_r ltx_border_t">8.1.3 The universal cover in type theory</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_l ltx_border_t"><span class="ltx_ERROR undefined">\metatable</span></td>
<td class="ltx_td ltx_border_t"></td>
</tr>
</tbody>
</table>
</div>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Feb  8 19:40:23 2018 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
