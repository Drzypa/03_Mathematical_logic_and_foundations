\documentclass[12pt]{article}
\usepackage{pmmeta}
\pmcanonicalname{A1TheFirstPresentation}
\pmcreated{2013-11-09 4:41:54}
\pmmodified{2013-11-09 4:41:54}
\pmowner{PMBookProject}{1000683}
\pmmodifier{PMBookProject}{1000683}
\pmtitle{A.1 The first presentation}
\pmrecord{4}{87883}
\pmprivacy{1}
\pmauthor{PMBookProject}{1000683}
\pmtype{Feature}
\pmclassification{msc}{03B15}

\usepackage{amssyb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\makeatletter
\newcommand{\conv}{\downarrow}
\newcommand{\defeq}{\vcentcolon\equiv}  
\newcommand{\define}[1]{\textbf{#1}}
\newcommand{\jdeq}{\equiv}      
\def\lam#1{{\lambda}\@lamarg#1:\@endlamarg\@ifnextchar\bgroup{.\,\lam}{.\,}}
\def\@lamarg#1:#2\@endlamarg{\if\relax\detokenize{#2}\relax #1\else\@lamvar{\@lameatcolon#2},#1\@endlamvar\fi}
\def\@lameatcolon#1:{#1}
\def\@lamvar#1,#2\@endlamvar{(#2\,{:}\,#1)}
\newcommand{\production}{\vcentcolon\vcentcolon=}
\newcommand{\vcentcolon}{:\!\!}
\makeatother

\begin{document}
The objects and types of our type theory may be written as terms using
the following syntax, which is an extension of $\lambda$-calculus with
\emph{variables} $x, x',\dots$,
\index{variable}%
\emph{primitive constants}
\index{primitive!constant}%
\index{constant!primitive}%
$c,c',\dots$, \emph{defined constants}\index{constant!defined} $f,f',\dots$, and term forming
operations
%
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]
%
The notation used here means that a term $t$ is either a variable $x$, or it
has the form $\lam{x} t$ where $x$ is a variable and $t$ is a term, or it has
the form $t(t')$ where $t$ and $t'$ are terms, or it is a primitive constant
$c$, or it is a defined constant $f$. The syntactic markers '$\lambda$', '(',
')', and '.' are punctuation for guiding the human eye.

We use $t(t_1,\dots,t_n)$ as an abbreviation for the repeated application
$t(t_1)(t_2)\dots (t_n)$. We may also use \emph{infix}\index{infix notation} notation, writing $t_1\;
\star\; t_2$ for $\star(t_1,t_2)$ when $\star$ is a primitive or defined
constant.

Each defined constant has zero, one or more \define{defining equations}.
\index{equation, defining}%
\index{defining equation}%
There are two kinds of defined constant. An \emph{explicit}
\index{constant!explicit}
defined constant $f$ has a single defining equation
  \[ f(x_1,\dots,x_n)\defeq t,\]
where $t$ does not involve $f$. 
%
For example, we might introduce the explicit defined constant $\circ$ with defining equation
  \[ \circ (x,y)(z) \defeq x(y(z)),\]
and use infix notation $x\circ y$ for $\circ(x,y)$. This of course is just composition of functions.

The second kind of defined constant is used to specify a (parameterized) mapping
$f(x_1,\dots,x_n,x)$, where $x$ ranges over a type whose elements are generated
by zero or more primitive constants.  For each such primitive constant $c$ there
is a defining equation of the form
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
where $f$ may occur in $t$, but only in such a way that it is clear that the
equations determine a totally defined function. The paradigm examples of such
defined functions are the functions defined by primitive recursion on the
natural numbers. We may call this kind of definition of a function a \emph{total
  recursive definition}.
\index{total!recursive definition}%
In computer science and logic this kind of definition
of a function on a recursive data type has been called a \define{definition by
  structural recursion}.
\index{definition!by structural recursion}%
\index{structural!recursion}%
\index{recursion!structural}%

\define{Convertibility}
\index{convertibility of terms}%
\index{term!convertibility of}%
$t \conv t'$ between terms $t$
and $t'$ is the equivalence relation generated by the defining equations for constants,
the computation rule\index{computation rule!for function types}
%
\[
  (\lam{x} t)(u) \defeq t[u/x],
\]
%
and the rules which make it a \emph{congruence} with respect to application and $\lambda$-abstraction\index{lambda abstraction@$\lambda$-abstraction}:
%
\begin{itemize}
\item if $t \conv t'$ and $s \conv s'$ then $t(s) \conv t'(s')$, and
\item if $t \conv t'$ then $(\lam{x} t) \conv (\lam{x} t')$.
\end{itemize}
\noindent
The equality judgment $t \jdeq u : A$ is then derived by the following single rule:
%
\begin{itemize}
\item if $t:A$, $u:A$, and $t \conv u$, then $t \jdeq u : A$.
\end{itemize}
%
Judgmental equality is an equivalence relation.

\end{document}
