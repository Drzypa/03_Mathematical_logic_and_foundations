\documentclass[12pt]{article}
\usepackage{pmmeta}
\pmcanonicalname{46SurjectionsAndEmbeddings}
\pmcreated{2013-11-17 23:46:04}
\pmmodified{2013-11-17 23:46:04}
\pmowner{PMBookProject}{1000683}
\pmmodifier{rspuzio}{6075}
\pmtitle{4.6 Surjections and embeddings}
\pmrecord{3}{87668}
\pmprivacy{1}
\pmauthor{PMBookProject}{6075}
\pmtype{Application}
\pmclassification{msc}{03B15}

\endmetadata

\usepackage{xspace}
\usepackage{amssyb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\makeatletter
\newcommand{\brck}[1]{\trunc{}{#1}}
\newcommand{\ct}{  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}}
\newcommand{\define}[1]{\textbf{#1}}
\def\@dprd#1{\prod_{(#1)}\,}
\def\@dprd@noparens#1{\prod_{#1}\,}
\def\@dsm#1{\sum_{(#1)}\,}
\def\@dsm@noparens#1{\sum_{#1}\,}
\def\@eatprd\prd{\prd@parens}
\def\@eatsm\sm{\sm@parens}
\newcommand{\eqvsym}{\simeq}    
\def\exis#1{\exists (#1)\@ifnextchar\bgroup{.\,\exis}{.\,}}
\def\fall#1{\forall (#1)\@ifnextchar\bgroup{.\,\fall}{.\,}}
\newcommand{\hfib}[2]{{\mathsf{fib}}_{#1}(#2)}
\newcommand{\id}[3][]{\ensuremath{#2 =_{#1} #3}\xspace}
\newcommand{\indexdef}[1]{\index{#1|defstyle}}   
\newcommand{\indexsee}[2]{\index{#1|see{#2}}}    
\newcommand{\isequiv}{\ensuremath{\mathsf{isequiv}}}
\newcommand{\mapfunc}[1]{\ensuremath{\mathsf{ap}_{#1}}\xspace} 
\newcommand{\opp}[1]{\mathord{{#1}^{-1}}}
\def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{\@ifnextchar\sm{\prd@parens{#1}\@eatsm}{\prd@noparens{#1}}}}
\def\prd@noparens#1{\mathchoice{\@dprd@noparens{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}
\def\prd@parens#1{\@ifnextchar\bgroup  {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\prd@parens}  {\@ifnextchar\sm    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\@eatsm}    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}}}
\def\sm#1{\@ifnextchar\bgroup{\sm@parens{#1}}{\@ifnextchar\prd{\sm@parens{#1}\@eatprd}{\sm@noparens{#1}}}}
\def\sm@noparens#1{\mathchoice{\@dsm@noparens{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}
\def\sm@parens#1{\@ifnextchar\bgroup  {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\sm@parens}  {\@ifnextchar\prd    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\@eatprd}    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}}}
\def\@tprd#1{\mathchoice{{\textstyle\prod_{(#1)}}}{\prod_{(#1)}}{\prod_{(#1)}}{\prod_{(#1)}}}
\newcommand{\trans}[2]{\ensuremath{{#1}_{*}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\newcommand{\trunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}\mathclose{}}
\def\@tsm#1{\mathchoice{{\textstyle\sum_{(#1)}}}{\sum_{(#1)}}{\sum_{(#1)}}{\sum_{(#1)}}}
\newcounter{mathcount}
\setcounter{mathcount}{1}
\newtheorem{precor}{Corollary}
\newenvironment{cor}{\begin{precor}}{\end{precor}\addtocounter{mathcount}{1}}
\renewcommand{\theprecor}{4.6.\arabic{mathcount}}
\newtheorem{predefn}{Definition}
\newenvironment{defn}{\begin{predefn}}{\end{predefn}\addtocounter{mathcount}{1}}
\renewcommand{\thepredefn}{4.6.\arabic{mathcount}}
\newenvironment{myeqn}{\begin{equation}}{\end{equation}\addtocounter{mathcount}{1}}
\renewcommand{\theequation}{4.6.\arabic{mathcount}}
\newtheorem{prethm}{Theorem}
\newenvironment{thm}{\begin{prethm}}{\end{prethm}\addtocounter{mathcount}{1}}
\renewcommand{\theprethm}{4.6.\arabic{mathcount}}
\let\apfunc\mapfunc
\let\autoref\cref
\makeatother

\begin{document}
\index{set}
When $A$ and $B$ are sets and $f:A\to B$ is an equivalence, we also call it as \define{isomorphism}
\indexdef{isomorphism!of sets}%
or a \define{bijection}.
\indexdef{bijection}%
\indexsee{function!bijective}{bijection}%
(We avoid these words for types that are not sets, since in homotopy theory and higher category theory they often denote a stricter notion of ``sameness'' than homotopy equivalence.)
In set theory, a function is a bijection just when it is both injective and surjective.
The same is true in type theory, if we formulate these conditions appropriately.
For clarity, when dealing with types that are not sets, we will speak of \emph{embeddings} instead of injections.

\begin{defn}
  Let $f:A\to B$.
  \begin{enumerate}
  \item We say $f$ is \define{surjective}
    \indexsee{surjective!function}{function, surjective}%
    \indexdef{function!surjective}%
    (or a \define{surjection})
    \indexsee{surjection}{function, surjective}%
    if for every $b:B$ we have $\brck{\hfib f b}$.
  \item We say $f$ is a \define{embedding}
    \indexdef{function!embedding}%
    \indexsee{embedding}{function, embedding}%
    if for every $x,y:A$ the function $\apfunc f : (\id[A]xy) \to (\id[B]{f(x)}{f(y)})$ is an equivalence.
  \end{enumerate}
\end{defn}

In other words, $f$ is surjective if every fiber of $f$ is merely inhabited, or equivalently if for all $b:B$ there merely exists an $a:A$ such that $f(a)=b$.
In traditional logical notation, $f$ is surjective if $\fall{b:B}\exis{a:A} (f(a)=b)$.
This must be distinguished from the stronger assertion that $\prd{b:B}\sm{a:A} (f(a)=b)$; if this holds we say that $f$ is a \define{split surjection}.
\indexsee{split!surjection}{function, split surjective}%
\indexsee{surjection!split}{function, split surjective}%
\indexsee{surjective!function!split}{function, split surjective}%
\indexdef{function!split surjective}%

If $A$ and $B$ are sets, then by \PMlinkname{Lemma 3.3.3}{33merepropositions#Thmprelem2}, $f$ is an embedding just when
\begin{myeqn}
  \prd{x,y:A} (\id[B]{f(x)}{f(y)}) \to (\id[A]xy).\label{eq:injective}
\end{myeqn}
In this case we say that $f$ is \define{injective},
\indexsee{injective function}{function, injective}%
\indexdef{function!injective}%
or an \define{injection}.
\indexsee{injection}{function, injective}%
We avoid these word for types that are not sets, because they might be interpreted as~\eqref{eq:injective}, which is an ill-behaved notion for non-sets.
It is also true that any function between sets is surjective if and only if it is an \emph{epimorphism} in a suitable sense, but this also fails for more general types, and surjectivity is generally the more important notion.

\begin{thm}\label{thm:mono-surj-equiv}
  A function $f:A\to B$ is an equivalence if and only if it is both surjective and an embedding.
\end{thm}
\begin{proof}
  If $f$ is an equivalence, then each $\hfib f b$ is contractible, hence so is $\brck{\hfib f b}$, so $f$ is surjective.
  And we showed in \PMlinkname{Theorem 2.11.1}{211identitytype#Thmprethm1} that any equivalence is an embedding.

  Conversely, suppose $f$ is a surjective embedding.
  Let $b:B$; we show that $\sm{x:A}(f(x)=b)$ is contractible.
  Since $f$ is surjective, there merely exists an $a:A$ such that $f(a)=b$.
  Thus, the fiber of $f$ over $b$ is inhabited; it remains to show it is a mere proposition.
  For this, suppose given $x,y:A$ with $p:f(x)=b$ and $q:f(y)=b$.
  Then since $\apfunc f$ is an equivalence, there exists $r:x=y$ with $\apfunc f (r) = p \ct \opp q$.
  However, using the characterization of paths in $\Sigma$-types, the latter equality rearranges to $\trans{r}{p} = q$.
  Thus, together with $r$ it exhibits $(x,p) = (y,q)$ in the fiber of $f$ over $b$.
\end{proof}

\begin{cor}
  For any $f:A\to B$ we have
  \[ \isequiv(f) \eqvsym (\mathsf{isEmbedding}(f) \times \mathsf{isSurjective}(f)).\]
\end{cor}
\begin{proof}
  Being a surjection and an embedding are both mere propositions; now apply \PMlinkname{Lemma 3.3.3}{33merepropositions#Thmprelem2}.
\end{proof}

Of course, this cannot be used as a definition of ``equivalence'', since the definition of embeddings refers to equivalences.
However, this characterization can still be useful; see \PMlinkname{\S 8.8}{88whiteheadstheoremandwhiteheadsprinciple}.
We will generalize it in \PMlinkexternal{Chapter 7}{http://planetmath.org/node/87580}.


% \section{Fiberwise equivalences}

\end{document}
