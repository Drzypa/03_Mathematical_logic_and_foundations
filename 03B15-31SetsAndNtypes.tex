\documentclass[12pt]{article}
\usepackage{pmmeta}
\pmcanonicalname{31SetsAndNtypes}
\pmcreated{2013-11-17 16:24:30}
\pmmodified{2013-11-17 16:24:30}
\pmowner{PMBookProject}{1000683}
\pmmodifier{rspuzio}{6075}
\pmtitle{3.1 Sets and n-types}
\pmrecord{4}{87648}
\pmprivacy{1}
\pmauthor{PMBookProject}{6075}
\pmtype{Feature}
\pmclassification{msc}{03B15}

\usepackage{xspace}
\usepackage{amssyb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\makeatletter
\newcommand{\bfalse}{{0_{\bool}}}
\newcommand{\bool}{\ensuremath{\mathbf{2}}\xspace}
\newcommand{\btrue}{{1_{\bool}}}
\newcommand{\ct}{  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}}
\newcommand{\defeq}{\vcentcolon\equiv}  
\newcommand{\define}[1]{\textbf{#1}}
\def\@dprd#1{\prod_{(#1)}\,}
\def\@dprd@noparens#1{\prod_{#1}\,}
\def\@dsm#1{\sum_{(#1)}\,}
\def\@dsm@noparens#1{\sum_{#1}\,}
\def\@eatprd\prd{\prd@parens}
\def\@eatsm\sm{\sm@parens}
\newcommand{\emptyt}{\ensuremath{\mathbf{0}}\xspace}
\newcommand{\funext}{\mathsf{funext}}
\newcommand{\happly}{\mathsf{happly}}
\newcommand{\id}[3][]{\ensuremath{#2 =_{#1} #3}\xspace}
\newcommand{\indexdef}[1]{\index{#1|defstyle}}   
\newcommand{\isset}{\ensuremath{\mathsf{isSet}}}
\newcommand{\mapdepfunc}[1]{\ensuremath{\mathsf{apd}_{#1}}\xspace} 
\newcommand{\mapfunc}[1]{\ensuremath{\mathsf{ap}_{#1}}\xspace} 
\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\pairpath}{\ensuremath{\mathsf{pair}^{\mathord{=}}}\xspace}
\def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{\@ifnextchar\sm{\prd@parens{#1}\@eatsm}{\prd@noparens{#1}}}}
\def\prd@noparens#1{\mathchoice{\@dprd@noparens{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}
\def\prd@parens#1{\@ifnextchar\bgroup  {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\prd@parens}  {\@ifnextchar\sm    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\@eatsm}    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}}}
\newcommand{\proj}[1]{\ensuremath{\mathsf{pr}_{#1}}\xspace}
\newcommand{\projpath}[1]{\ensuremath{\apfunc{\proj{#1}}}\xspace}
\newcommand{\refl}[1]{\ensuremath{\mathsf{refl}_{#1}}\xspace}
\def\sm#1{\@ifnextchar\bgroup{\sm@parens{#1}}{\@ifnextchar\prd{\sm@parens{#1}\@eatprd}{\sm@noparens{#1}}}}
\def\sm@noparens#1{\mathchoice{\@dsm@noparens{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}
\def\sm@parens#1{\@ifnextchar\bgroup  {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\sm@parens}  {\@ifnextchar\prd    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\@eatprd}    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}}}
\def\@tprd#1{\mathchoice{{\textstyle\prod_{(#1)}}}{\prod_{(#1)}}{\prod_{(#1)}}{\prod_{(#1)}}}
\newcommand{\trans}[2]{\ensuremath{{#1}_{*}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\def\@tsm#1{\mathchoice{{\textstyle\sum_{(#1)}}}{\sum_{(#1)}}{\sum_{(#1)}}{\sum_{(#1)}}}
\newcommand{\unit}{\ensuremath{\mathbf{1}}\xspace}
\newcommand{\UU}{\ensuremath{\mathcal{U}}\xspace}
\newcommand{\vcentcolon}{:\!\!}
\newcounter{mathcount}
\setcounter{mathcount}{1}
\newtheorem{predefn}{Definition}
\newenvironment{defn}{\begin{predefn}}{\end{predefn}\addtocounter{mathcount}{1}}
\renewcommand{\thepredefn}{3.1.\arabic{mathcount}}
\newtheorem{preeg}{Example}
\newenvironment{eg}{\begin{preeg}}{\end{preeg}\addtocounter{mathcount}{1}}
\renewcommand{\thepreeg}{3.1.\arabic{mathcount}}
\newtheorem{prelem}{Lemma}
\newenvironment{lem}{\begin{prelem}}{\end{prelem}\addtocounter{mathcount}{1}}
\renewcommand{\theprelem}{3.1.\arabic{mathcount}}
\let\apdfunc\mapdepfunc
\let\apfunc\mapfunc
\let\autoref\cref
\let\nat\N
\let\type\UU
\makeatother

\begin{document}
\index{set|(defstyle}%

In order to explain the connection between the logic of type theory and the logic of set theory, it is helpful to have a notion of \emph{set} in type theory.
While types in general behave like spaces or higher groupoids, there is a subclass of them that behave more like the sets in a traditional set-theoretic system.
Categorically, we may consider \emph{discrete} groupoids, which are determined by a set of objects and only identity morphisms as higher morphisms; while topologically, we may consider spaces having the discrete topology.\index{discrete!space}
More generally, we may consider groupoids or spaces that are \emph{equivalent} to ones of this sort; since everything we do in type theory is up to homotopy, we can't expect to tell the difference.

Intuitively, we would expect a type to ``be a set'' in this sense if it has no higher homotopical information: any two parallel paths are equal (up to homotopy), and similarly for parallel higher paths at all dimensions.
Fortunately, because everything in homotopy type theory is automatically functorial/continuous,
\index{continuity of functions in type theory@``continuity'' of functions in type theory}%
\index{functoriality of functions in type theory@``functoriality'' of functions in type theory}%
it turns out to be sufficient to ask this at the bottom level.

\begin{defn}\label{defn:set}
  A type $A$ is a \define{set}
  if for all $x,y:A$ and all $p,q:x=y$, we have $p=q$.
\end{defn}

More precisely, the proposition $\isset(A)$ is defined to be the type
\[ \isset(A) \defeq \prd{x,y:A}{p,q:x=y} (p=q). \]

As mentioned in \PMlinkname{\S 1.1}{11typetheoryversussettheory},
the sets in homotopy type theory are not like the sets in ZF set theory, in that there is no global ``membership predicate'' $\in$.
They are more like the sets used in structural mathematics and in category theory, whose elements are ``abstract points'' to which we give structure with functions and relations.
This is all we need in order to use them as a foundational system for most set-based mathematics; we will see some examples in \PMlinkexternal{Chapter 10}{http://planetmath.org/node/87584}.

Which types are sets?
In \PMlinkexternal{Chapter 7}{http://planetmath.org/node/87580} we will study a more general form of this question in depth, but for now we can observe some easy examples.

\begin{eg}
  The type \unit is a set.
  For by \PMlinkname{Theorem 2.8.1}{28theunittype#S8.Thmthm1}, for any $x,y:\unit$ the type $(x=y)$ is equivalent to \unit.
  Since any two elements of \unit are equal, this implies that any two elements of $x=y$ are equal.
\end{eg}

\begin{eg}
  The type $\emptyt$ is a set, for given any $x,y:\emptyt$ we may deduce anything we like, by the induction principle of $\emptyt$.
\end{eg}

\begin{eg}\label{thm:nat-set}
  The type \nat of natural numbers is also a set.
  This follows from \PMlinkname{Theorem 2.13.1}{213naturalnumbers#Thmprethm1}, since all equality types $\id[\nat]xy$ are equivalent to either \unit or \emptyt, and any two inhabitants of \unit or \emptyt are equal.
  We will see another proof of this fact in \PMlinkexternal{Chapter 7}{http://planetmath.org/node/87580}.
\end{eg}

Most of the type forming operations we have considered so far also preserve sets.

\begin{eg}\label{thm:isset-prod}
  If $A$ and $B$ are sets, then so is $A\times B$.
  For given $x,y:A\times B$ and $p,q:x=y$, by \PMlinkname{Theorem 2.6.2}{26cartesianproducttypes#Thmprethm1} we have $p= \pairpath(\projpath1(p),\projpath2(p))$ and $q= \pairpath(\projpath1(q),\projpath2(q))$.
  But $\projpath1(p)=\projpath1(q)$ since $A$ is a set, and $\projpath2(p)=\projpath2(q)$ since $B$ is a set; hence $p=q$.

  Similarly, if $A$ is a set and $B:A\to\type$ is such that each $B(x)$ is a set, then $\sm{x:A} B(x)$ is a set.
\end{eg}

\begin{eg}\label{thm:isset-forall}
  If $A$ is \emph{any} type and $B:A\to \type$ is such that each $B(x)$ is a set, then the type $\prd{x:A} B(x)$ is a set.
  For suppose $f,g:\prd{x:A} B(x)$ and $p,q:f=g$.
  By function extensionality, we have
  %
  \begin{equation*}
    p = {\funext (x \mapsto \happly(p,x))}
    \quad\text{and}\quad
    q = {\funext (x \mapsto \happly(q,x))}.
  \end{equation*}
  %
  But for any $x:A$, we have
  %
  \begin{equation*}
   \happly(p,x):f(x)=g(x)
   \qquad\text{and}\qquad
   \happly(q,x):f(x)=g(x), 
  \end{equation*}
  %
  so since $B(x)$ is a set we have $\happly(p,x) = \happly(q,x)$.
  Now using function extensionality again, the dependent functions $(x \mapsto \happly(p,x))$ and $(x \mapsto \happly(q,x))$ are equal, and hence (applying $\apfunc{\funext}$) so are~$p$ and~$q$.
\end{eg}

For more examples, see \PMlinkexternal{Exercise 3.2}{http://planetmath.org/node/87828},\PMlinkexternal{Exercise 3.3}{http://planetmath.org/node/87768}.  For a more systematic investigation of the subsystem (category) of all sets in homotopy type theory, see~\PMlinkexternal{Chapter 10}{http://planetmath.org/node/87584}.

\index{n-type@$n$-type|(}%

Sets are just the first rung on a ladder of what are called \emph{homotopy $n$-types}.
The next rung consists of \emph{$1$-types}, which are analogous to $1$-groupoids in category theory.
The defining property of a set (which we may also call a \emph{$0$-type}) is that it has no non-trivial paths.
Similarly, the defining property of a $1$-type is that it has no non-trivial paths between paths:

\begin{defn}\label{defn:1type}
  A type $A$ is a \define{1-type}
  \indexdef{1-type}%
  if for all $x,y:A$ and $p,q:x=y$ and $r,s:p=q$, we have $r=s$.
\end{defn}

Similarly, we can define $2$-types, $3$-types, and so on.
We will define the general notion of $n$-type inductively in \PMlinkexternal{Chapter 7}{http://planetmath.org/node/87580}, and study the relationships between them.

However, for now it is useful to have two facts in mind.
First, the levels are upward-closed: if $A$ is an $n$-type then $A$ is an $(n+1)$-type.
For example:
%%  will make precise the sense in which this
%% ``suffices for all higher levels'', but as an example, we observe that
%% it suffices for the next level up.

\begin{lem}\label{thm:isset-is1type}
  If $A$ is a set (that is, $\isset(A)$ is inhabited), then $A$ is a 1-type.
\end{lem}
\begin{proof}
  Suppose $f:\isset(A)$; then for any $x,y:A$ and $p,q:x=y$ we have $f(x,y,p,q):p=q$.
  Fix $x$, $y$, and $p$, and define $g: \prd{q:x=y} (p=q)$ by $g(q) \defeq f (x,y,p,q)$.
  Then for any $r:q=q'$, we have $\apdfunc{g}(r) : \trans{r}{g(q)} = g(q')$.
  By \PMlinkname{Lemma 1}{211identitytype#Thmlem1}, therefore, we have $g(q) \ct r = g(q')$.

  In particular, suppose given $x,y,p,q$ and $r,s:p=q$, as in \PMlinkname{Definition 3.1.7}{31setsandntypes#Thmpredefn2}, and define $g$ as above.
  Then $g(p) \ct r = g(q)$ and also $g(p) \ct s = g(q)$, hence by cancellation $r=s$.
\end{proof}

Second, this stratification of types by level is not degenerate, in the
sense that not all types are sets:  

\begin{eg}\label{thm:type-is-not-a-set}
  \index{type!universe}%
  The universe \type is not a set.
  To prove this, it suffices to exhibit a type $A$ and a path $p:A=A$ which is not equal to $\refl A$.
  Take $A=\bool$, and let $f:A\to A$ be defined by $f(\bfalse)\defeq \btrue$ and $f(\btrue)\defeq \bfalse$.
  Then $f(f(x))=x$ for all $x$ (by an easy case analysis), so $f$ is an equivalence.
  Hence, by univalence, $f$ gives rise to a path $p:A=A$.

  If $p$ were equal to $\refl A$, then (again by univalence) $f$ would equal the identity function of $A$.
  But this would imply that $\bfalse=\btrue$, contradicting \PMlinkname{Remark 1}{212coproducts#Thmrmk1}.
\end{eg}

In \PMlinkexternal{Chapter 6}{http://planetmath.org/node/87579},\PMlinkexternal{Chapter 8}{http://planetmath.org/node/87582} we will show that for any $n$, there are types which are not $n$-types.

Note that $A$ is a 1-type exactly when for any $x,y:A$, the identity type $\id[A]xy$ is a set.
(Thus, \PMlinkname{Lemma 3.1.8}{31setsandntypes#Thmprelem1} could equivalently be read as saying that the identity types of a set are also sets.)
This will be the basis of the recursive definition of $n$-types we will give in \PMlinkexternal{Chapter 7}{http://planetmath.org/node/87580}.

We can also extend this characterization ``downwards'' from sets.
That is, a type $A$ is a set just when for any $x,y:A$, any two elements of $\id[A]xy$ are equal.
Since sets are equivalently 0-types, it is natural to call a type a \emph{$(-1)$-type} if it has this latter property (any two elements of it are equal).
Such types may be regarded as \emph{propositions in a narrow sense}, and their study is just what is usually called ``logic''; it will occupy us for the rest of this chapter.

\index{n-type@$n$-type|)}%
\index{set|)}%


\end{document}
